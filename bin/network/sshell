#!/bin/bash
#
# Run with --help for help.
# Host name can be retrieved from the name of the script (also in case the
# script is actually a symbolic link).
#
# Script versions:
# < 1.0: developement versions
# 1.0 (petrillo@fnal.gov, 20141004)
#     tested long enough to have it official
# 1.1 (petrillo@fnal.gov, 20141004)
#     added --asuser option
# 1.2 (20141114, petrillo@fnal.gov)
#   added exec option
# 1.3 (20150830, petrillo@fnal.gov)
#   added "ping" mode
# 1.4 (20161227, petrillo@fnal.gov)
#   added "mount" mode
#

SCRIPTNAME="$(basename "$0")"
SCRIPTDIR="$(dirname "$0")"
CWD="$(pwd)"

SCRIPTVERSION="1.4"

# program paths
: ${kinit:="kinit"}
: ${ssh:="ssh"}
: ${scp:="scp"}
: ${mkdir:="mkdir"}
: ${ping:="ping"}
: ${sshfs:="sshfs"}

ssh_default_options=( '-X' )
# ssh_default_options=( '-X' '-Y' )

DefaultBaseMountPoint="${HOME}/Volumes"


function help() {
	cat <<-EOH
	Operates on a remote server via SSH.

	Usage:  ${SCRIPTNAME}  [options] [--] [parameters]

	The script operates in one of the following modes, specified as options:

	--ssh [default]
	    opens an iterative shell on the remote host
	--read , -r , read , r
	    copies the specified files from a directory in the remote server into
	    the current directory
	--write , -w , write , w
	    writes the specified files into a directory in the remote server
	--exec , -x , exec , x
	    executes a command on the remote host
	--ping , -p , ping , p
	    executes ping with the specified parameters
	--mount , -m , mount , m
	    mounts the remote directory into the specified one
	--version , -V
	    just prints the version numbre and exits
	--help , -h , -?
	    just prints this help message and exits

	Each mode can have its specific options, in addition to commonly accepted
	ones:

	EOH
	help_common
} # help()


function help_common() {
	cat <<-EOH
	Verbosity options:
	--fake
	    only writes the commands it would execute (usually assumes they succeed)
	--debug[=LEVEL]
	    enables debugging output
	--verbose
	    increases the verbosity of the program (e.g. prints the commands it
	    executes)
	--quiet
	    decreases the verbosity of the command

	SSH options:
	--user=REMOTEUSER [${USER}]
	    uses this user for remote log in
	--asuser=ASREMOTEUSER [as REMOTEUSER]
	    uses this user for remote log in, but still uses REMOTEUSER above in the
	    authentication (see below)
	--nouser
	    do not specify the user (ASREMOTEUSER above); count on SSH to know better
	--host=HOSTNAME
	    the name of the SSH server to be contacted
	--domain=DOMAIN
	    if specified, it is appended to the host name unless the latter already
	    includes a domain
	--autohost[=ScriptName]
	    if no host name is specified, it uses the script name as host name,
	    unless the script name matches ScriptName; if ScriptName is omitted,
	    'sshell' is used. This option can be specified multiple times to exclude
	    multiple script names
	--hostprefix=PREFIX
	    prepends PREFIX to the host name
	--hostsuffix=SUFFIX
	    appends SUFFIX to the host name

	Kerberos authentication options (see \`man 1 kinit\` for details):
	--k5realm=KRB5REALM
	--k5user=KRB5USER [as ASREMOTEUSER, or REMOTEUSER]
	--k5instance=KRB5USERINSTANCE [as ASREMOTEUSER, or not used]
	    if a Kerberos5 realm is specified, a ticket will be obtained from that
	    realm, using KRB5USER as user (by default, the same as --remote option)
	    and an optional instance KRB5USERINSTANCE (e.g. 'root' for administration
	    privileges)
	--nonew
	    do not attempt to get a new Kerberos ticket (can still renew an existing
	    one)
	--norenew
	    do not attempt to renew an existing ticket (can still obtain a new one)
	--noticket
	    do not attempt to get a Kerberos ticket at all (equivalent to
	    options --nonew and --norenew together)
	--k5lifetime=LIFETIME ['${KerberosTicketLifetime}']
	    when requesting a new ticket, ask it to last for lifetime (it may still
	    be renewed beyond it)
	--k5enewtime=RENEWTIME ['${KerberosTicketRenewTime}']
	    when requesting a new ticket, ask to allow it to be renewed up to
	    RENEWTIME time (in total)
	--notrenewable
	    requested Kerberos ticket is not renewable
	EOH
} # help_common()


function help_help() {
	cat <<-EOH
	Mode: help

	  ${SCRIPTNAME}  <--help[=Mode]|-h|-?>

	Prints help about this script, or about its specified mode if Mode is
	specified.

	EOH
} # help_help()


function help_version() {
	cat <<-EOH
	Mode: version

	  ${SCRIPTNAME}  <--version|-V>

	Prints the version of this script.

	EOH
} # help_version()


function help_read() {
	cat <<-EOH
	Mode: read
	  ${SCRIPTNAME}  <--read|-r|read|r> [options]
	    [--dest=DEST] source [source ...]
	    [--dest=DEST source [source ...]]
	  ${SCRIPTNAME}  <--read|-r|read|r> [options] [--]
	    source [source ...] [destination]

	Reads the specified remote files into the local host.
	If a relative source path is specified, it is relative to the directory where
	ssh lands (typically, user's home directory).
	Each destination option (below) refers to the following sources, up to the
	next destination option.
	The sources before the first destination option (if any) are copied to the
	first specified destination.
	In the second form, where no destination option is specified, the destination
	for all the source files is the last parameter. If only one parameter is
	present, it is interpreted as a source to be copied to the current directory.

	If the destination can be detected to be a directory, that directory is
	created. A destination is detected as a directory if it is destination for
	multiple sources or if its name ends in '/'.

	Read mode options:
	--src=SOURCE
	    specifies a remote source; alternative way to specify sources.
	    If a relative path is specified, it is relative to the directory where
	    ssh lands (typically, user's home directory)
	--dest=DESTDIR
	    the directory in the local host where to copy the following sources

	In addition, the common options are accepted:

	EOH
	help_common
} # help_read()


function help_write() {
	cat <<-EOH
	Mode: write
	  ${SCRIPTNAME}  <--write|-w|write|w> [options]
	    [--dest=DEST] source [source ...]
	    [--dest=DEST source [source ...]]
	  ${SCRIPTNAME}  <--write|-w|write|w> [options] [--]
	    source [source ...] [destination]

	Writes the specified local files to the remote server.
	Each destination option (below) refers to the following sources, up to the
	next destination option.
	The sources before the first destination option (if any) are copied to the
	first specified destination.
	In the second form, where no destination option is specified, the destination
	for all the source files is the last parameter. If only one parameter is
	present, it is interpreted as a source to be copied to the directory where
	ssh lands on the remote server (".", typically, user's home directory).

	Write mode options:
	--src=SOURCE
	    specifies a source; alternative way to specify sources
	--dest=DESTDIR
	    the directory under the remote host where to copy the following sources;
	    if a relative path is specified, it is relative to the directory where
	    ssh lands (typically, user's home directory)

	In addition, the common options are accepted:

	EOH
	help_common
} # help_write()


function help_exec() {
	cat <<-EOH
	Mode: write
	  ${SCRIPTNAME}  <--exec|-x|exec|x> [options]
	    command [command arguments...]

	Executes the specified command in the remote shell, then returns.

	Execution mode options:
	  no specific one

	In addition, the common options are accepted:

	EOH
	help_common
} # help_exec()


function help_ping() {
	cat <<-EOH
	Mode: ping
	  ${SCRIPTNAME}  <--ping|-p|ping|p> [options] [--] [ping options]

	Executes ping on the server. Arguments are passed to ping.

	Ping mode options:
	  no specific one

	The common options are accepted:

	EOH
} # help_ping()


function help_mount() {
	cat <<-EOH
	Mode: mount
	  ${SCRIPTNAME}  <--mount|mount> [options] [MountPoint] [--] [SSHFS options]
	
	Mounts a remote directory into the specified one. The additional optiosn are
	passed to SSHFS.
	If no mount point is specified, <BaseMountPoint>/<ServerName> is used
	(<BaseMountPoint> can be specified as an option).
	
	SSHFS is required.
	
	Mount mode options:
	--remotedir=REMOTEDIR [default: the remote home directory]
	    mounts the specified remote directory
	--basedir=BASEMOUNTPOINT ['${DefaultBaseMountPoint}']
	    if mount directory is not specified, it's created under this directory
	
	The common options are accepted:
	
	EOH
} # help_mount()


function isFlagSet() {
	local VARNAME="$1"
	[[ -n "${!VARNAME//0}" ]]
}

function isFlagUnset() {
	local VARNAME="$1"
	[[ -z "${!VARNAME//0}" ]]
}

function isFlagOver() {
	local VARNAME="$1"
	local Threshold="${2:-"1"}"
	[[ -n "${!VARNAME}" ]] && [[ "${!VARNAME}" -ge "$Threshold" ]]
}

function STDERR() { echo "$*" >&2 ; }

function STDERRN() { echo -n "$*" >&2 ; }

function ERROR() { STDERR "ERROR: $*" ; }

function FATAL() {
	local Code=$1
	shift
	STDERR "FATAL (${Code}): $*"
	exit $Code
} # FATAL()

function LASTFATAL() {
	local -i ExitCode="$?"
	[[ $ExitCode == 0 ]] || FATAL $ExitCode "$*"
} # LASTFATAL()


function isDebugging() { isFlagOver DEBUG $1 ; }

function DBG() { isDebugging && STDERR "DBG| $*" ; }

function DBGN() {
	local Level="$1"
	shift
	isDebugging $Level && STDERR "DBG[${Level}]| $*"
} # DBGN()

function CMDDBG() {
	isDebugging || return
	for Par in "$@" ; do STDERRN "'${Par}' " ; done
	STDERR ""
} # CMDDBG()

function DUMPVAR() {
	local VarName="$1"
#	DBG "${VarName}='${!VarName}'"
  local Value
  Value="$(declare -p "$VarName" 2> /dev/null)"
  local -i Code=$?
  if [[ "$Code" == 0 ]]; then
    DBG "${Value}"
  else
    DBG "'${VarName}' not defined!"
  fi
} # DUMPVAR()

function DUMPVARS() {
	isDebugging || return
	local VarName
	for VarName in "$@" ; do
		DUMPVAR "$VarName"
	done
} # DUMPVARS()


function MSG() { isFlagSet QUIET || echo "$@" ; }

function FileFromDescriptor() {
	# Prints the file associated to the descriptor
	local -i Descriptor="$1"

	if [[ -d '/proc' ]]; then
		# lucky us, there is procfs
		local FD="/proc/${$}/fd/0"
		[[ -e "$FD" ]] || return 1 # but there is no such file descriptor!
		readlink "$FD"
		return 0
	else
		case "$Descriptor" in
			( * ) return 1 ;;
		esac
	fi
} # FileFromDescriptor()


function SetOperationMode() {
	local Mode="$1"
	if [[ -n "$MODE" ]]; then
		if [[ "$Mode" != "$MODE" ]]; then
			FATAL 1 "Conflicting mode specifications: ${MODE} and ${Mode}"
		else
			STDERR "WARNING: mode '${Mode}' set more than once."
			return
		fi
	fi
	MODE="$Mode"
} # SetOperationMode()


function Max() {
	[[ $# -gt 0 ]] || return 1
	local -i Max=$1
	local -i iItem
	for (( iItem = 2 ; iItem <= $# ; ++iItem )); do
		local Item="${!iItem}"
		[[ -z "$Item" ]] && continue
		[[ "$Item" -gt "$Max" ]] && Max="$Item"
	done
	echo "$Max"
	return 0
} # Max()


function RedirectOutput() {
	# Redirects the specified file descriptor to a specified file, and prints
	# the previous one.
	local -i FileDescriptor="$1"
	local RedirectTo="$2"
	[[ -n "$RedirectTo" ]] || return 1

	local ProcHandle="/proc/$$/fd/${FileDescriptor}"
	local OldOutput
	[[ -h "$ProcHandle" ]] && OldOutput="$(readlink "$ProcHandle")"

	local res=0
	exec "${FileDescriptor}>" "$RedirectTo"
	res=$?
	[[ $res == 0 ]] || return $res

	echo "$OldOutput"
	return 0
} # RedirectOutput()


function Execute() {
	local StdIn StdOut StdErr
	while [[ "${1:0:1}" == '-' ]]; do
		case "$1" in
			( '--muteoutput' )
				StdOut="/dev/null"
				;;
			( '--muteerror' )
				StdErr="/dev/null"
				;;
			( '--mute' )
				StdOut="/dev/null"
				StdErr="/dev/null"
				;;
			( '--' )
				shift
				break ;;
			( * )
				break ;;
		esac
		shift
	done

	local -a Command=( "$@" )
	local -i ExitCode=0

	# print the command being run
	if isFlagSet FAKE || isFlagSet VERBOSE || isDebugging ; then
		echo "CMD: ${Command[@]} ${StdIn:+"0< '${StdIn}'"} ${StdOut:+"1> '${StdOut}'"} ${StdErr:+"2> '${StdErr}'"}"
	fi

	# run the command
	if isFlagUnset FAKE ; then
		# establish redirections
		local OldStdIn OldStdOut OldStdErr
		if [[ -n "$StdIn" ]]; then
			OldStdIn="$(FileFromDescriptor 0)"
			if [[ $? == 0 ]]; then
				DBGN 3 "Saving standard input: '${OldStdIn}'"
				exec 0< "$StdIn"
			else
				DBGN 3 "Not muting STDIN since we can't detect where it is directed"
			fi
		fi
		if [[ -n "$StdOut" ]]; then
			OldStdOut="$(FileFromDescriptor 1)"
			if [[ $? == 0 ]]; then
				DBGN 3 "Saving standard output: '${OldStdOut}'"
				exec 1> "$StdOut"
			else
				DBGN 3 "Not muting STDOUT since we can't detect where it is directed"
			fi
		fi
		if [[ -n "$StdErr" ]]; then
			OldStdErr="$(FileFromDescriptor 2)"
			if [[ $? == 0 ]]; then
				DBGN 3 "Saving standard error: '${OldStdErr}'"
				exec 2> "$StdErr"
			else
				DBGN 3 "Not muting STDERR since we can't detect where it is directed"
			fi
		fi

		"${Command[@]}"
		ExitCode=$?
		DBG "Exit code for '${Command[0]}': ${ExitCode}"

		# reset redirections; plenty of bugs if procfs is not availableß
		if [[ -n "$OldStdErr" ]]; then
			exec 2> "$OldStdErr"
			DBGN 3 "Standard error restored to '${OldStdErr}'"
		fi
		if [[ -n "$OldStdOut" ]]; then
			exec 1> "$OldStdOut"
			DBGN 3 "Standard output restored to '${OldStdOut}'"
		fi
		if [[ -n "$OldStdIn" ]]; then
			exec 0< "$OldStdIn"
			DBGN 3 "Standard input restored to '${OldStdIn}'"
		fi

	fi

	return $ExitCode
} # Execute()


function TransferData() {
	#
	# Usage:  TransferData  Destination Sources ...
	#
	local Destination="$1"
	shift
	local -a Sources=( "$@" )
	Execute rsync -av -e ssh "${Sources[@]}" "$Destination"
} # TransferData()


function CheckExecutable() {
  local ExecPath="$1"
  
  which "$ExecPath" || FATAL 2 "Can't find the required executable '${ExecPath}'."
  
} # CheckExecutable()


################################################################################
###
### parameter parser
###

function parse_options_common() {
	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a common option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		case "$Param" in

			# verbosity options
			( "--fake" )          FAKE=1 ;;
			( "--debug" )         DEBUG=1 ;;
			( "--debug="* )       DEBUG="${Param#--*=}" ;;
			( "--verbose" )       let ++VERBOSE ;;
			( "--quiet" )         let ++QUIET ;;

			# SSH options
			( "--user="* )        RemoteUser="${Param#--*=}" ;;
			( "--asuser="* )      AsRemoteUser="${Param#--*=}" ;;
			( "--nouser" )        NoAsRemoteUser=1 ;;
			( "--server="* | '--host='* )
			                      RemoteHost="${Param#--*=}" ;;
			( "--domain="* )      RemoteDomain="${Param#--*=}" ;;
			( "--sshopt="* )      ssh_options=( "${ssh_options[@]}" "${Param#--*=}" ) ;;
			( "--nodefopts="* )   NoDefaultSSHoptions=1 ;;
			( "--autohost" )      AutoHost=( "${AutoHost[@]}" 'sshell' ) ;;
			( "--autohost="* )    AutoHost=( "${AutoHost[@]}" "${Param#--*=}" ) ;;
			( "--hostprefix="* )  RemoteHostPrefix="${Param#--*=}" ;;
			( "--hostsuffix="* )  RemoteHostSuffix="${Param#--*=}" ;;

			# Kerberos options
			( "--k5realm="* )     KerberosRealm="${Param#--*=}" ;;
			( "--k5user="* )      KerberosUser="${Param#--*=}" ;;
			( "--k5instance="* )  KerberosInstance="${Param#--*=}" ;;
			( "--nonew" )         KerberosNewTicket=0 ;;
			( "--norenew" )       KerberosRenewTicket=0 ;;
			( "--noticket" )      KerberosNewTicket=0 ; KerberosRenewTicket=0 ;;
			( "--k5lifetime=" )   KerberosTicketLifetime="${Param#--*=}" ;;
			( "--k5renewtime=" )  KerberosTicketRenewTime="${Param#--*=}" ;;
			( "--notrenewable" )  KerberosTicketRenewTime='' ;;
			( "--nat=" )          isNAT=1 ;;
			( * )
				return $(( NDigested - 1 ))
		esac
		break
	done
	return $NDigested
} # parse_options_common()


function parse_options_help() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		# by default, assume we swallow one parameter only
		let ++NDigested

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		case "$Param" in
			( '--help' | '-h' | '-?' ) HelpTopics=( "${HelpTopics[@]}" 'help' ) ;;
			( '--version' | '-V' )     HelpTopics=( "${HelpTopics[@]}" 'version' ) ;;
			( '--ssh' )                HelpTopics=( "${HelpTopics[@]}" 'ssh' ) ;;
			( '--write' | '-w' | 'write' | 'w' ) HelpTopics=( "${HelpTopics[@]}" 'write' ) ;;
			( '--read' | '-r' | 'read' | 'r' )   HelpTopics=( "${HelpTopics[@]}" 'read' ) ;;
			( '--exec' | '-x' | 'exec' | 'x' ) HelpTopics=( "${HelpTopics[@]}" 'exec' ) ;;

			( * )
				[[ "$MODE" == 'help' ]] && FATAL 1 "No help available on '${Param}'"
				return $(( NDigested - 1 ))
		esac
		break
	done
	return $NDigested
} # parse_options_help()


function parse_options_ssh() {
	local -i iParam=$(( $1 - 1 ))
	shift

	local Param="${!iParam}"

	DBGN 3 "  is '${Param}' a ${MODE} option?"

	# accept all the options as SSH options
	ssh_options=( "${ssh_options[@]}" "$Param" )

	return 1
} # parse_options_ssh()


function parse_options_write() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( "--dest="* )
					CurrentDestination="${Param#--*=}"
					: ${DefaultDestination:="$CurrentDestination"}
					;;
				( "--src="* )
					Destinations=( "${Destinations[@]}" "$CurrentDestination" )
					Sources=( "${Sources[@]}" "${Param#--*=}" )
					;;
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			Destinations=( "${Destinations[@]}" "$CurrentDestination" )
			Sources=( "${Sources[@]}" "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_write()

function parse_options_read() { parse_options_write "$@" ; }

function parse_options_exec() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			NoMoreOptions=1
			Command=( "${Command[@]}" "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_exec()

function parse_options_ping() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( * )
					FATAL 1 "Invalid ${MODE} mode option '${Param}'."
			esac
		else
			NoMoreOptions=1
			Options=( "${Options[@]}" "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_ping()


function parse_options_mount() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0
	
	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( "--remotedir="* )
					Sources=( "${Param#--*=}" )
					;;
				( "--basedir="* )
					BaseMountPoint="${Param#--*=}"
					;;
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			[[ "${#Destinations[@]}" == 0 ]] || FATAL 1 "Too many mount points specified ('${Param}')."
			
			Destinations=( "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_mount()


function set_environment() {
	# Sets the environment for the specified mode
	local Mode="$1"

	local SetEnvironmentProc="set_environment_${Mode}"

	DBGN 1 "Setting environment for mode '${Mode}'"

	# start from a default environment
	set_default_environment

	declare -f "$SetEnvironmentProc" >& /dev/null
	if [[ $? != 0 ]]; then
		DBGN 2 "No specific environment found."
		return
	fi

	"$SetEnvironmentProc"

} # set_environment()

function set_default_environment() {
	# sets variables for a generic environment

	KerberosNeeded=1
	NoAsRemoteUser=0
	
} # set_default_environment()

function set_environment_ping() {
	DBGN 2 "Setting the environment for ping mode."

	# Kerberos is not needed to ping the server:
	KerberosNeeded=0

} # set_environment_ping()


declare MODE=""
declare -i NoMoreOptions=0

declare -i DEBUG=0 QUIET=0 VERBOSE=0 FAKE=0

declare RemoteUser="$USER" RemoteHost='' RemoteDomain=''
declare RemoteHostPrefix='' RemoteHostSuffix=''
declare -a AutoHost
declare -i NoDefaultSSHoptions=0

declare KerberosRealm='' KerberosUser="" KerberosInstance=''
declare KerberosTicketLifetime='1d' KerberosTicketRenewTime='7d'
declare -i KerberosNewTicket=1 KerberosRenewTicket=1 isNAT=0

declare -a Sources Destinations Command
declare -i nSources=0
declare CurrentDestination='' DefaultDestination=''
declare -a ssh_options

declare -i iParam=0 nParams=$#
while [[ $iParam -lt $nParams ]]; do
	let ++iParam
	Param="${!iParam}"

	DBGN 2 "Parsing parameter: '${Param}'"

	if isFlagUnset NoMoreOptions ; then

		# is this the marker of no more options?
		if [[ "$Param" == '--' ]] || [[ "$Param" == '-' ]]; then
			NoMoreOptions=1
			continue
		fi

		# if mode has not been set yet, give it a try
		if [[ -z "$MODE" ]]; then
			case "$Param" in
				( '--help' | '-h' | '-?' | 'help' )  SetOperationMode 'help' ;;
				( '--version' | '-V' | 'version' )   SetOperationMode 'version' ;;
				( '--ssh' | 'ssh' )                  SetOperationMode 'ssh' ;;
				( '--write' | '-w' | 'write' | 'w' ) SetOperationMode 'write' ;;
				( '--read' | '-r' | 'read' | 'r' )   SetOperationMode 'read' ;;
				( '--exec' | '-x' | 'exec' | 'x' )   SetOperationMode 'exec' ;;
				( '--ping' | '-p' | 'ping' | 'p' )   SetOperationMode 'ping' ;;
				( '--mount' | '-m' | 'mount' | 'm' ) SetOperationMode 'mount' ;;
			esac
			[[ -n "$MODE" ]] && continue
		fi

		# special option (includes a mode set):
		case "$Param" in
			( '--help='* )
				SetOperationMode 'help'
				HelpTopics=( "${HelpTopics[@]}" "${Param#--*=}" )
				continue
				;;
		esac

		# parse the common options
		parse_options_common "$iParam" "$@"
		HandledParameters=$?
		if [[ "$HandledParameters" -ge 1 ]]; then
			# we have handled some parameters, let's skip them
			let iParam+=${HandledParameters}-1
			continue
		fi
	fi

	# mode-specific options (valid only if a mode is specified)
	if [[ -n "$MODE" ]]; then
		parse_options_${MODE} "$iParam" "$@"
		HandledParameters=$?
		if [[ "$HandledParameters" -ge 1 ]]; then
			# we have handled some parameters, let's skip them
			let iParam+=${HandledParameters}-1
			continue
		fi
	fi

done

isFlagSet NoDefaultSSHoptions || ssh_options=( "${ssh_default_options[@]}" "${ssh_options[@]}" )
nSources="${#Sources[@]}"

: ${MODE:='ssh'}

isFlagSet QUIET && VERBOSE=0
: ${KerberosUser:="$RemoteUser"}



################################################################################
### Simple operational modes
###

case "$MODE" in
	( 'help' )
		if [[ "${#HelpTopics[*]}" == 0 ]]; then
			help
		else
			for HelpTopic in "${HelpTopics[@]}" ; do
				help_${HelpTopic}
				LASTFATAL "Error while printing help on topic '${HelpTopic}'"
			done
		fi
		exit 0
		;;
	( 'version' )
		RealName="$(basename "$(readlink -f "$0")")"
		if [[ "$RealName" == "${SCRIPTNAME}" ]]; then
			echo "${SCRIPTNAME} version ${SCRIPTVERSION}"
		else
			echo "${SCRIPTNAME} (alias of ${RealName}) version ${SCRIPTVERSION}"
		fi
		exit 0
		;;
esac


################################################################################
### Arrange SSH options
###

if [[ -z "$RemoteHost" ]] && [[ ${#AutoHost[@]} -gt 0 ]] ; then
	RemoteHost="$SCRIPTNAME"
	DBG "Using '${RemoteHost}' as host name (unless in ${AutoHost[@]})."
	for ScriptName in "${AutoHost[@]}" ; do
		[[ "$RemoteHost" == "$ScriptName" ]] || continue
		DBG "Host name '${RemoteHost}' is actually a script name."
		unset RemoteHost
		break
	done
fi

[[ -n "$RemoteHost" ]] || FATAL 1 "Remote host specification is required."


# RemoteHostName is the simple host name (no domain/DNS name)
declare RemoteHostName="${RemoteHost%%.*}"

DBGN 2 "Detected remote host: '${RemoteHost}'"
DBGN 3 "Base host name:       '${RemoteHostName}'"
DBGN 3 "Domain name:          '${RemoteDomain}'"

# RemoteDomainFromHostName is the rest of the host specification (no trailing . though)
declare RemoteDomainFromHostName="${RemoteHost#${RemoteHostName}.}"
[[ "$RemoteDomainFromHostName" == "$RemoteHost" ]] && RemoteDomainFromHostName=''
DBGN 3 "Embedded domain name: '${RemoteDomainFromHostName}'"

# rework the host name
[[ "${RemoteHostName#${RemoteHostPrefix}}" == "$RemoteHostName" ]] && RemoteHostName="${RemoteHostPrefix}${RemoteHostName}"
[[ "${RemoteHostName%${RemoteHostSuffix}}" == "$RemoteHostName" ]] && RemoteHostName+="${RemoteHostSuffix}"

DBGN 2 "Complete host name:   '${RemoteHostName}'"

# RemotePath is the fully qualified host + domain name
declare RemotePath="${RemoteHostName}${RemoteDomainFromHostName:+.${RemoteDomainFromHostName}}"
[[ -n "$RemoteDomain" ]] && [[ -z "$RemoteDomainFromHostName" ]] && RemotePath+=".${RemoteDomain}"

DBGN 3 "Complete host path:   '${RemotePath}'"



if [[ -n "$AsRemoteUser" ]]; then
	: ${KerberosInstance:="$AsRemoteUser"}
	: ${KerberosUser:="$RemoteUser"}
elif isFlagSet NoAsRemoteUser ; then
	AsRemoteUser=''
else
	AsRemoteUser="$RemoteUser"
fi

declare RemoteFullPath="${AsRemoteUser:+${AsRemoteUser}@}${RemotePath}"
DBGN 2 "Complete user path:   '${RemoteFullPath}'"

set_environment "$MODE"


################################################################################
### Get a Kerberos ticket as needed
###

if isFlagUnset KerberosNeeded ; then
	DBGN 1 "No Kerberos authentication is needed."
elif [[ -n "$KerberosRealm" ]]; then


	declare -i GotKerberosTicket=0

	KerberosUserInstance="${KerberosUser}${KerberosInstance:+/${KerberosInstance}}"
	KerberosFullUser="${KerberosUserInstance}@${KerberosRealm}"

	DBGN 1 "Preparing for Kerberos authentication as: '${KerberosFullUser}'"

	# first try to renew an existing ticket
	if isFlagUnset GotKerberosTicket && isFlagSet KerberosRenewTicket ; then
		DBGN 2 " - attempt to renew any existing ticket"
		Execute --mute $kinit -R "$KerberosFullUser" && GotKerberosTicket=1
	else
		DBGN 2 " (no attempt to renew any existing ticket)"
	fi

	if isFlagUnset GotKerberosTicket && isFlagSet KerberosNewTicket ; then

		DBGN 2 " - attempt to obtain a new ticket"
		declare -a KerberosOptions=(
			${KerberosTicketLifetime:+"-l${KerberosTicketLifetime}"}
			${KerberosTicketRenewTime:+"-r${KerberosTicketRenewTime}"}
		)
		isFlagSet isNAT && KerberosOptions=( "${KerberosOptions[@]}" '-n' )

		echo "Getting a new Kerberos5 ticket: prepare your password."
		Execute $kinit "${KerberosOptions[@]}" "$KerberosFullUser" && GotKerberosTicket=1
	else
		DBGN 2 " (no attempt to obtain a new ticket)"
	fi

	if isFlagUnset GotKerberosTicket ; then
		ERROR "Couldn't get a new Kerberos5 ticket. Hope there is a valid, existing one."
	fi

else
	DBGN 1 "No Kerberos authentication was requested."
fi


################################################################################
### SSH communication modes
###
declare -i ExitCode=0
case "$MODE" in
	#############################################################################
	( 'ssh' )
		Execute $ssh ${AsRemoteUser:+-l "$AsRemoteUser"} "${ssh_options[@]}" "$RemotePath"
		ExitCode=$?
		;;

	#############################################################################
	( 'read' | 'write' )
		# if no destination was ever explicitly specified, assume that the latest
		# parameter is the destination for all the sources;
		# if there is only one source, then assume the destination is the default
		# directory SSH lands to
		if [[ -z "$DefaultDestination" ]]; then
			if [[ $nSources -gt 1 ]]; then
				let --nSources
				DefaultDestination="${Sources[$nSources]}"
				unset Sources[$nSources]
				unset Destinations[$nSources]
			else
				DefaultDestination='.'
			fi
		fi

		[[ $nSources == 0 ]] && FATAL 1 "In ${MODE} mode, at least one source must be specified!"

		declare -i nErrors=0
		declare -i iSource=0
		while [[ $iSource -lt $nSources ]] ; do
			# accumulate sources to be copied into the same destination
			declare -a TheseSources=( )

			declare ThisDestination="${Destinations[iSource]:-${DefaultDestination}}"
			while [[ "${Destinations[iSource]:-${DefaultDestination}}" == "$ThisDestination" ]]; do
				TheseSources=( "${TheseSources[@]}" "${Sources[iSource]}" )

				let ++iSource
				[[ $iSource -ge $nSources ]] && break
			done

			# -r: recursive directory copy; -p: preserve attributes
			if [[ "$MODE" == 'write' ]]; then
				FullDestination="${RemoteFullPath}:${ThisDestination}"
				TransferData "$FullDestination" "${TheseSources[@]}"
			else
				FullDestination="$ThisDestination"
				declare -a FullSources=( )
				for Source in "${TheseSources[@]}" ; do
					FullSources=( "${FullSources[@]}" "${RemoteFullPath}:${Source}" )
				done
				if [[ "${#FullSources[@]}" -gt 1 ]] || [[ "${FullDestination: -1}" == '/' ]]; then
					Execute $mkdir -p "$FullDestination"
				fi
				TransferData "$FullDestination" "${FullSources[@]}"
			fi
			ExitCode=$?
			if [[ $ExitCode != 0 ]]; then
				ERROR "Copy to '${FullDestination}' failed!"
				let ++nErrors
			fi
		done
		exit $nErrors
		;;

	#############################################################################
	( 'exec' )
		Execute $ssh -l "$RemoteUser" "${ssh_options[@]}" "$RemotePath" "${Command[@]}"
		ExitCode=$?
		;;

	#############################################################################
	( 'ping' )
		Execute $ping "${Options[@]}" -- "$RemotePath"
		ExitCode=$?
		;;

	#############################################################################
	( 'mount' )
		MountPoint="${Destinations[0]}"
		: ${BaseMountPoint:="$DefaultBaseMountPoint"}
		: ${MountPoint:="${BaseMountPoint:+${BaseMountPoint%/}/}${RemotePath}"}
		
		Execute $mkdir -p "$MountPoint"
		LASTFATAL 1 "Can't write the mount point '${MountPoint}'"
		
		RemoteDir="${RemotePath}:${Sources[0]}"
		
		Execute $sshfs "$RemoteDir" "$MountPoint" "${Options[@]}"
		ExitCode=$?
		[[ $ExitCode == 0 ]] && MSG "'${RemoteDir}' mounted at '${MountPoint}'. Unmount with \`umount '${MountPoint}'\`."
		;;

	#############################################################################
	( * ) FATAL 1 "Unknown SSH operation '${MODE}'." ;;
esac


exit $ExitCode
