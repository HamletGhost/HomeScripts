#!/bin/bash
#
# Run with --help for help.
# Host name can be retrieved from the name of the script (also in case the
# script is actually a symbolic link).
#
# Script versions:
# < 1.0: developement versions
# 1.0 (petrillo@fnal.gov, 20141004)
#     tested long enough to have it official
# 1.1 (petrillo@fnal.gov, 20141004)
#     added --asuser option
# 1.2 (20141114, petrillo@fnal.gov)
#   added exec option
# 1.3 (20150830, petrillo@fnal.gov)
#   added "ping" mode
# 1.4 (20161227, petrillo@fnal.gov)
#   added "mount" mode
# 1.5 (20161228, petrillo@fnal.gov)
#   added "umount" mode
# 1.6 (20170303, petrillo@fnal.gov)
#   added forced unmount option
# 1.7 (20170811, petrillo@fnal.gov)
#   login name not passed any more by default
# 1.8 (20171202, petrillo@fnal.gov)
#   added --ip option
# 1.9 (20190820, petrillo@slac.stanford.edu)
#   added tunnel mode
# 1.10 (20190826, petrillo@slac.stanford.edu)
#   changes the tunnel mode to support multiple tunnels on the same connection;
#   also fixed tunnel mode help
# 1.11 (20200303, petrillo@slac.stanford.edu)
#   added awareness of whether authentication is confirmed valid, and some
#   behaviour depending on that
# 1.12 (20200303, petrillo@slac.stanford.edu)
#   added Kerberos ticket forwarding (again?)
# 1.13 (20210719, petrillo@slac.stanford.edu)
#   added SOCKS mode
# 1.14 (20220308, petrillo@slac.stanford.edu)
#   added VNC helper option
# 1.15 (20220614, petrillo@slac.stanford.edu)
#   added `--relative` option for copy
# 1.16 (20240805, petrillo@slac.stanford.edu)
#   added `--opt` documentation
#

SCRIPTNAME="$(basename "$0")"
SCRIPTDIR="$(dirname "$0")"
CWD="$(pwd)"

SCRIPTVERSION="1.16"

# program paths
: ${kinit:="kinit"}
: ${ssh:="ssh"}
: ${mkdir:="mkdir"}
: ${ping:="ping"}
: ${sshfs:="sshfs"}

ssh_default_options=( '-X' )
# ssh_default_options=( '-X' '-Y' )
transfer_default_options=( '--verbose' '--archive' )

declare -r DefaultBaseMountPoint="${HOME}/Volumes"
declare -ir DefaultCompressComm="1"
declare -ir DefaultSOCKS5port="1080"


function help() {
	cat <<-EOH
	Operates on a remote server via SSH.

	Usage:  ${SCRIPTNAME}  [options] [--] [parameters]

	The script operates in one of the following modes, specified as options:

	--ssh [default]
	    opens an iterative shell on the remote host
	--read , -r , read , r
	    copies the specified files from a directory in the remote server into
	    the current directory
	--write , -w , write , w
	    writes the specified files into a directory in the remote server
	--exec , -x , exec , x
	    executes a command on the remote host
	--ping , -p , ping , p
	    executes ping with the specified parameters
	--mount , -m , mount , m
	    mounts the remote directory into the specified one
	--umount , -u , umount , u
	    unmounts the remote directory previously mounted with the 'mount' mode
	--socks , --proxy , -s , proxy , s
	    opens a SOCKS5 proxy from \`localhost\` to the remote server, port ${DefaultSOCKS5port}
	--tunnel , -T , tunnel , T
	    opens a tunnel to the remote server accessed via the specified port
	--version , -V
	    just prints the version numbre and exits
	--help , -h , -?
	    just prints this help message and exits

	Each mode can have its specific options, in addition to commonly accepted
	ones:

	EOH
	help_common
} # help()


function help_common() {
	cat <<-EOH
	Verbosity options:
	--fake
	    only writes the commands it would execute (usually assumes they succeed)
	--debug[=LEVEL]
	    enables debugging output
	--verbose
	    increases the verbosity of the program (e.g. prints the commands it
	    executes)
	--quiet
	    decreases the verbosity of the command

	SSH options:
	--user=REMOTEUSER [${USER}]
	    uses this user for remote log in
	--asuser=ASREMOTEUSER [as REMOTEUSER]
	    uses this user for remote log in, but still uses REMOTEUSER above in the
	    authentication (see below)
	--nouser
	    do not specify the user (ASREMOTEUSER above); count on SSH to know better
	--host=HOSTNAME
	    the name of the SSH server to be contacted
	--domain=DOMAIN
	    if specified, it is appended to the host name unless the latter already
	    includes a domain
	--ip=IP4ADDRESS
# 	    after resolving the remote host IP, replaces the lowest IP4 bytes with
	    the specified ones; for example, on a host resolving to 192.168.1.1,
	    \`--ip=129.3\` will result in a target host IP of 192.168.129.3
	--autohost[=ScriptName]
	    if no host name is specified, it uses the script name as host name,
	    unless the script name matches ScriptName; if ScriptName is omitted,
	    'sshell' is used. This option can be specified multiple times to exclude
	    multiple script names
	--hostprefix=PREFIX
	    prepends PREFIX to the host name
	--hostsuffix=SUFFIX
	    appends SUFFIX to the host name
	--jump=[USER@]NODE , --hop=[USER@]NODE
	    uses the specified server to reach the destination; if specified multiple
	    times, it will set jumps in sequence
	--sshopt=OPT
	    uses the SSH option OPT, which should be a single word option
	--sshfullopt="OPT value"
	    uses the SSH option OPT passed as an \`-o\` argument

	Kerberos authentication options (see \`man 1 kinit\` for details):
	--k5realm=KRB5REALM
	--k5user=KRB5USER [as ASREMOTEUSER, or REMOTEUSER]
	--k5instance=KRB5USERINSTANCE [as ASREMOTEUSER, or not used]
	    if a Kerberos5 realm is specified, a ticket will be obtained from that
	    realm, using KRB5USER as user (by default, the same as --remote option)
	    and an optional instance KRB5USERINSTANCE (e.g. 'root' for administration
	    privileges)
	--nonew
	    do not attempt to get a new Kerberos ticket (can still renew an existing
	    one)
	--norenew
	    do not attempt to renew an existing ticket (can still obtain a new one)
	--noticket
	    do not attempt to get a Kerberos ticket at all (equivalent to
	    options --nonew and --norenew together)
	--k5lifetime=LIFETIME ['${KerberosTicketLifetime}']
	    when requesting a new ticket, ask it to last for lifetime (it may still
	    be renewed beyond it)
	--k5enewtime=RENEWTIME ['${KerberosTicketRenewTime}']
	    when requesting a new ticket, ask to allow it to be renewed up to
	    RENEWTIME time (in total)
	--notrenewable
	    requested Kerberos ticket is not renewable
	EOH
} # help_common()


function help_help() {
	cat <<-EOH
	Mode: help

	  ${SCRIPTNAME}  <--help[=Mode]|-h|-?>

	Prints help about this script, or about its specified mode if Mode is
	specified.

	EOH
} # help_help()


function help_version() {
	cat <<-EOH
	Mode: version

	  ${SCRIPTNAME}  <--version|-V>

	Prints the version of this script.

	EOH
} # help_version()


function help_read() {
	cat <<-EOH
	Mode: read
	  ${SCRIPTNAME}  <--read|-r|read|r> [options]
	    [--dest=DEST] source [source ...]
	    [--dest=DEST source [source ...]]
	  ${SCRIPTNAME}  <--read|-r|read|r> [options] [--]
	    source [source ...] [destination]

	Reads the specified remote files into the local host.
	If a relative source path is specified, it is relative to the directory where
	ssh lands (typically, user's home directory).
	Each destination option (below) refers to the following sources, up to the
	next destination option.
	The sources before the first destination option (if any) are copied to the
	first specified destination.
	In the second form, where no destination option is specified, the destination
	for all the source files is the last parameter. If only one parameter is
	present, it is interpreted as a source to be copied to the current directory.

	If the destination can be detected to be a directory, that directory is
	created. A destination is detected as a directory if it is destination for
	multiple sources or if its name ends in '/'.

	Read mode options:
	--src=SOURCE
	    specifies a remote source; alternative way to specify sources.
	    If a relative path is specified, it is relative to the directory where
	    ssh lands (typically, user's home directory)
	--dest=DESTDIR
	    the directory in the local host where to copy the following sources
	--relative , -r
	    copies the files from the specified directory of the remote host to the
	    same subdirectory in the local one; source (remote) directory may be
	    absolute, in which case the exact same path is recreated in the local
	    host, or relative, in which case it is assumed to come from the home
	    directory in the remote host and it is replicated in the local home
	    directory; the second form of the command, with \`destination\` argument,
	    is not supported when this option is selected, and all arguments are
	    interpreted as sources. If \`--dest\` is specified, it is prepended to the
	    destination directory: if the value of this option is also relative,
	    the latter is added under the local host home directory.
	--opt=OPTION
	    the specified option is passed to the copy command (not the connection
	    one; that is, to \`rsync\` rather than to \`ssh\`)

	In addition, the common options are accepted:

	EOH
	help_common
} # help_read()


function help_ssh() {
	cat <<-EOH
	Mode: ssh
	  ${SCRIPTNAME}  [--ssh|ssh] [options]
	
	Opens a SSH connection and executes a shell on the remote side.
	This is the "standard" SSH mode.
	All options and parameters that are not of this script are passed directly
	as options to SSH, in the same order as they are specified.
	
	SSH mode options:
	--vnc[=[LocalPort:]RemotePort]
	    forwards the port LocalPort to the port RemotePort on the remote server;
	    any connection on the local host at LocalPort will become a connection
	    to \`localhost\` in the remote host. This parameter is tuned for VNC
	    connections: RemotePort must be in the 5900-5999 range (default 5901).
	    If less than 100, both port parameters are added 5900 (i.e. \`--vnc=10:1\`
	    is equivalent to \`--vnc=5910:5901\`). If the local port is not specified,
	    it is assigned the same value as \`RemotePort\`.
	    To use the VNC X server on the remote side, DISPLAY must be set as:
	    
	    export DISPLAY='localhost:ShortRemotePort'
	    
	    (\`ShortRemotePort\` is the RemotePort minus 5900, i.e. between 1 and 99;
	    The local side can access it opening a VNC viewer at LocalPort.

	In addition, the common options are accepted:

	EOH
	help_common
	
} # help_ssh()


function help_write() {
	cat <<-EOH
	Mode: write
	  ${SCRIPTNAME}  <--write|-w|write|w> [options]
	    [--dest=DEST] source [source ...]
	    [--dest=DEST source [source ...]]
	  ${SCRIPTNAME}  <--write|-w|write|w> [options] [--]
	    source [source ...] [destination]

	Writes the specified local files to the remote server.
	Each destination option (below) refers to the following sources, up to the
	next destination option.
	The sources before the first destination option (if any) are copied to the
	first specified destination.
	In the second form, where no destination option is specified, the destination
	for all the source files is the last parameter. If only one parameter is
	present, it is interpreted as a source to be copied to the directory where
	ssh lands on the remote server (".", typically, user's home directory).

	Write mode options:
	--src=SOURCE
	    specifies a source; alternative way to specify sources
	--dest=DESTDIR
	    the directory under the remote host where to copy the following sources;
	    if a relative path is specified, it is relative to the directory where
	    ssh lands (typically, user's home directory)
	--relative , -r
	    copies the files from the specified directory of the local host to the
	    same subdirectory in the remote one; source (local) directory may be
	    absolute, in which case the exact same path is recreated in the local
	    host, or relative, in which case it is expanded to absolute based on the
	    current directory. If the source is in the local home directory, it will
	    be replicated in the remote local directory. The second form of the
	    command, with \`destination\` argument, is not supported when this option
	    is selected, and all arguments are interpreted as sources. If \`--dest\`
	    is specified, it is prepended to the destination directory: if the value
	    of this option is relative, the latter is added under the remote host
	    home directory.

	In addition, the common options are accepted:

	EOH
	help_common
} # help_write()


function help_exec() {
	cat <<-EOH
	Mode: write
	  ${SCRIPTNAME}  <--exec|-x|exec|x> [options]
	    command [command arguments...]

	Executes the specified command in the remote shell, then returns.

	Execution mode options:
	  no specific one

	In addition, the common options are accepted:

	EOH
	help_common
} # help_exec()


function help_ping() {
	cat <<-EOH
	Mode: ping
	  ${SCRIPTNAME}  <--ping|-p|ping|p> [options] [--] [ping options]

	Executes ping on the server. Arguments are passed to ping.

	Ping mode options:
	  no specific one

	The common options are accepted:

	EOH
	help_common
} # help_ping()


function help_tunnel() {
	cat <<-EOH
	Mode: tunnel
	  ${SCRIPTNAME}  <--tunnel|-T|tunnel|T> [options] [--] [tunnel options] target [command]

	The target is a remote server plus port specification,
	\`localport=>[remotetarget:]remoteport\`, with \`remotetarget\` being
	"localhost" by default.
	An SSH tunnelling connection is opened to reach each of the specified remote
	targets, from the port \`localport\` on this node (that is,
	\`localhost:localport\`) to the \`remoteport\` port on the \`remotetarget\`
	node, passing through the host${RemoteHost=+" ${RemoteHost}"} as specified in ${SCRIPTNAME} (\`-L\` option).
	If a command is specified, it is executed on the host and the connection is
	closed after the command terminates. Otherwise, an interactive shell is opened
	unless \`--background\` option is specified.

	Tunnel mode options:
	--background , -f
	  if specified, the SSH connection is set in the background

	The common options are accepted:

	EOH
	help_common
} # help_tunnel()


function help_proxy() {
	local CompressCommStr="not compressed"
	isFlagSet DefaultCompressComm && CompressCommStr="compressed"
	
	cat <<-EOH
	Mode: proxy
	  ${SCRIPTNAME}  <--proxy|--socks|-s|proxy|s> [options]
	
	Opens a SOCKS5 proxy at the remote server, using OpenSSH dynamic port
	forwarding feature.
	
	Proxy mode options:
	--background
	    detaches the SSH session: the shell will be available, but the tunnel will
	    need to be closed manually
	--compression , --nocompression  [${CompressCommStr}]
	    use, or not, compression in SSH communication
	--port=PORT ['${DefaultSOCKS5port}']
	    use this port for the local binding
	--localhost=host ['localhost']
	    use this host for the local binding

	In addition, the common options are accepted:

	EOH
	help_common
} # help_proxy()


function help_mount() {
	cat <<-EOH
	Mode: mount
	  ${SCRIPTNAME}  <--mount|mount> [options] [MountPoint] [--] [SSHFS options]

	Mounts a remote directory into the specified one. The additional options are
	passed to SSHFS.
	If no mount point is specified, <BaseMountPoint>/<ServerName> is used
	(<BaseMountPoint> can be specified as an option).

	SSHFS is required.

	Mount mode options:
	--remotedir=REMOTEDIR [default: the remote home directory]
	    mounts the specified remote directory
	--basedir=BASEMOUNTPOINT ['${DefaultBaseMountPoint}']
	    if mount directory is not specified, it's created under this directory
	--remount
	    if the target is already mounted, tries to remount it
	--force , -f
	    tries to push through errors to get the target mounted

	The common options are accepted:

	EOH
	help_common
} # help_mount()


function help_umount() {
	cat <<-EOH
	Mode: mount
	  ${SCRIPTNAME}  <--umount|umount> [options]

	Unmounts a remote directory that has been mounted before.
	It needs the same remote directory argument as the mount command.

	Mount mode options:
	--remotedir=REMOTEDIR [default: the remote home directory]
	    ummounts the specified remote directory
	--force , -f
	    ask the system to force unmounting

	The common options are accepted (most are just ignored):

	EOH
	help_common
} # help_umount()


function isFlagSet() {
	local VARNAME="$1"
	[[ -n "${!VARNAME//0}" ]]
}

function isFlagUnset() {
	local VARNAME="$1"
	[[ -z "${!VARNAME//0}" ]]
}

function isFlagOver() {
	local VARNAME="$1"
	local Threshold="${2:-"1"}"
	[[ -n "${!VARNAME}" ]] && [[ "${!VARNAME}" -ge "$Threshold" ]]
}

function ifFlagSet() {
	# ifFlagSet FLAGNAME TrueString [FalseString]
	# 
	# Prints <TrueString> if FLAGNAME is set, <FalseString> otherwise (which by
	# default it is empty, in which case nothing is printed).
	#
	local -r FlagName="$1"
	local -r TrueString="$2"
	local -r FalseString="$3"
	
	if isFlagSet "$FlagName" ; then
		echo "$TrueString"
		true # for the return value
	else
		[[ $# -ge 3 ]] && echo "$FalseString"
		false # for the return value
	fi
} # ifFlagSet()

function STDERR() { echo "$*" >&2 ; }

function STDERRN() { echo -n "$*" >&2 ; }

function ERROR() { STDERR "ERROR: $*" ; }

function FATAL() {
	local Code=$1
	shift
	STDERR "FATAL (${Code}): $*"
	exit $Code
} # FATAL()

function LASTFATAL() {
	local -i ExitCode="$?"
	[[ $ExitCode == 0 ]] || FATAL $ExitCode "$*"
} # LASTFATAL()


function isDebugging() { isFlagOver DEBUG $1 ; }

function DBG() { isDebugging && STDERR "DBG| $*" ; }

function DBGN() {
	local Level="$1"
	shift
	isDebugging $Level && STDERR "DBG[${Level}]| $*"
} # DBGN()

function CMDDBG() {
	isDebugging || return
	for Par in "$@" ; do STDERRN "'${Par}' " ; done
	STDERR ""
} # CMDDBG()

function DUMPVAR() {
	local VarName="$1"
#	DBG "${VarName}='${!VarName}'"
  local Value
  Value="$(declare -p "$VarName" 2> /dev/null)"
  local -i Code=$?
  if [[ "$Code" == 0 ]]; then
    DBG "${Value}"
  else
    DBG "'${VarName}' not defined!"
  fi
} # DUMPVAR()

function DUMPVARS() {
	isDebugging || return
	local VarName
	for VarName in "$@" ; do
		DUMPVAR "$VarName"
	done
} # DUMPVARS()

function isOSX() {
	[[ "$(uname)" == 'Darwin' ]]
}


function MSG() { isFlagSet QUIET || echo "$@" ; }

function startsWithDir() {
	# Usage:  startsWithDir Path BaseDir
	local Path="$1"
	local BaseDir="$2"
	
	[[ "$Path" == "$BaseDir" ]] || [[ "${Path#${BaseDir}/}" != "$Path" ]]
	
} # startsWithDir()

function isAbsolutePath() { [[ "${1:0:1}" == '/' ]] ; }

function makeAbsolutePath() {
	local Path="$1"
	local BaseDir="${2:-${CWD}}"
	
	if ! isAbsolutePath "$Path" ; then
		# not fool-proof, better than nothing:
		while true ; do
			if startsWithDir "$Path" '.' ; then
				Path="${Path:2}"
			elif startsWithDir "$Path" '..' ; then
				Path="${Path:3}"
				BaseDir="$(dirname "$BaseDir")"
			else
				break
			fi
		done
		Path="${BaseDir%/}/${Path}"
	fi
	echo "$Path"
} # makeAbsolutePath()


function JoinStrings() {
	# JoinStrings  Sep [string] [...]
	
	local Sep="$1"
	shift
	local -i NJumps="$#"
	[[ $NJumps == 0 ]] && echo "" && return
	printf "$1"
	shift
	[[ $NJumps -gt 1 ]] && printf "${Sep}%s" "$@"
	return 0
} # JoinStrings()


function FileFromDescriptor() {
	# Prints the file associated to the descriptor
	local -i Descriptor="$1"

	if [[ -d '/proc' ]]; then
		# lucky us, there is procfs
		local FD="/proc/${$}/fd/0"
		[[ -e "$FD" ]] || return 1 # but there is no such file descriptor!
		readlink "$FD"
		return 0
	else
		case "$Descriptor" in
			( * ) return 1 ;;
		esac
	fi
} # FileFromDescriptor()


function SetOperationMode() {
	local Mode="$1"
	if [[ -n "$MODE" ]]; then
		if [[ "$Mode" != "$MODE" ]]; then
			FATAL 1 "Conflicting mode specifications: ${MODE} and ${Mode}"
		else
			STDERR "WARNING: mode '${Mode}' set more than once."
			return
		fi
	fi
	MODE="$Mode"
	local -r ModeParameters="init_parameters_${MODE}"
	declare -f "$ModeParameters" >& /dev/null && "$ModeParameters"

} # SetOperationMode()


function Max() {
	[[ $# -gt 0 ]] || return 1
	local -i Max=$1
	local -i iItem
	for (( iItem = 2 ; iItem <= $# ; ++iItem )); do
		local Item="${!iItem}"
		[[ -z "$Item" ]] && continue
		[[ "$Item" -gt "$Max" ]] && Max="$Item"
	done
	echo "$Max"
	return 0
} # Max()


function RedirectOutput() {
	# Redirects the specified file descriptor to a specified file, and prints
	# the previous one.
	local -i FileDescriptor="$1"
	local RedirectTo="$2"
	[[ -n "$RedirectTo" ]] || return 1

	local ProcHandle="/proc/$$/fd/${FileDescriptor}"
	local OldOutput
	[[ -h "$ProcHandle" ]] && OldOutput="$(readlink "$ProcHandle")"

	local res=0
	exec "${FileDescriptor}>" "$RedirectTo"
	res=$?
	[[ $res == 0 ]] || return $res

	echo "$OldOutput"
	return 0
} # RedirectOutput()


function Execute() {
	local StdIn StdOut StdErr
	while [[ "${1:0:1}" == '-' ]]; do
		case "$1" in
			( '--muteoutput' )
				StdOut="/dev/null"
				;;
			( '--muteerror' )
				StdErr="/dev/null"
				;;
			( '--mute' )
				StdOut="/dev/null"
				StdErr="/dev/null"
				;;
			( '--' )
				shift
				break ;;
			( * )
				break ;;
		esac
		shift
	done

	local -a Command=( "$@" )
	local -i ExitCode=0

	# print the command being run
	if isFlagSet FAKE || isFlagSet VERBOSE || isDebugging ; then
		echo "CMD:$(printf " '%s'" "${Command[@]}") ${StdIn:+"0< '${StdIn}'"} ${StdOut:+"1> '${StdOut}'"} ${StdErr:+"2> '${StdErr}'"}"
	fi

	# run the command
	if isFlagUnset FAKE ; then
		# establish redirections
		local OldStdIn OldStdOut OldStdErr
		if [[ -n "$StdIn" ]]; then
			OldStdIn="$(FileFromDescriptor 0)"
			if [[ $? == 0 ]]; then
				DBGN 3 "Saving standard input: '${OldStdIn}'"
				exec 0< "$StdIn"
			else
				DBGN 3 "Not muting STDIN since we can't detect where it is directed"
			fi
		fi
		if [[ -n "$StdOut" ]]; then
			OldStdOut="$(FileFromDescriptor 1)"
			if [[ $? == 0 ]]; then
				DBGN 3 "Saving standard output: '${OldStdOut}'"
				exec 1> "$StdOut"
			else
				DBGN 3 "Not muting STDOUT since we can't detect where it is directed"
			fi
		fi
		if [[ -n "$StdErr" ]]; then
			OldStdErr="$(FileFromDescriptor 2)"
			if [[ $? == 0 ]]; then
				DBGN 3 "Saving standard error: '${OldStdErr}'"
				exec 2> "$StdErr"
			else
				DBGN 3 "Not muting STDERR since we can't detect where it is directed"
			fi
		fi

		"${Command[@]}"
		ExitCode=$?
		DBG "Exit code for '${Command[0]}': ${ExitCode}"

		# reset redirections; plenty of bugs if procfs is not availableÃŸ
		if [[ -n "$OldStdErr" ]]; then
			exec 2> "$OldStdErr"
			DBGN 3 "Standard error restored to '${OldStdErr}'"
		fi
		if [[ -n "$OldStdOut" ]]; then
			exec 1> "$OldStdOut"
			DBGN 3 "Standard output restored to '${OldStdOut}'"
		fi
		if [[ -n "$OldStdIn" ]]; then
			exec 0< "$OldStdIn"
			DBGN 3 "Standard input restored to '${OldStdIn}'"
		fi


	fi

	return $ExitCode
} # Execute()


function TransferData() {
	#
	# Usage:  TransferData  Destination Sources ...
	#
	local Destination="$1"
	shift
	local -a Sources=( "$@" )
	local -a Options=( "${TransferOptions[@]}" )
	[[ "${#Options[@]}" == 0 ]] && Options=( "${transfer_default_options[@]}" )
	Execute rsync "${Options[@]}" -e ssh "${Sources[@]}" "$Destination"
} # TransferData()


function CheckExecutable() {
  local ExecPath="$1"

  which "$ExecPath" || FATAL 2 "Can't find the required executable '${ExecPath}'."

} # CheckExecutable()


function SetMountPoint() {
	MountPoint="$1"
	: ${BaseMountPoint:="$DefaultBaseMountPoint"}
	: ${MountPoint:="${BaseMountPoint:+${BaseMountPoint%/}/}${RemoteHostID}"}
} # SetMountPoint()


function Mount() {
	if isOSX && ! which fusermount >& /dev/null ; then
		Execute --mute mount "$MountPoint"
	else
		Execute --mute fusermount "$MountPoint"
	fi
}

function Unmount() {
	if isOSX && ! which fusermount >& /dev/null ; then
		Execute --mute umount "$MountPoint"
	else
		Execute --mute fusermount -u "$MountPoint"
	fi
}

function isIP6() {
	local IP="$1"
	[[ -n "IP" ]] && [[ "$IP" =~ ^([0-9A-Fa-f]{1,4})?(:([0-9A-Fa-f]{0,4})){0,7}$ ]]
} # isIP6()

function isIP4() {
	local IP="$1"
	[[ -n "$IP" ]] && [[ "$IP" =~ ^([0-9]{1,3}|[0-9A-Fa-f]{2})?(\.([0-9]{1,3}|[0-9A-Fa-f]{2})?){0,3}$ ]]
} # isIP4()

function SplitAt() {
	local -r Sep="$1"
	local -r N="$2"
	local Src="$3"

	DBGN 4 "Splitting '${Src}' with '${Sep}'"
	local -a Tokens
	if [[ -n "$Src" ]]; then
		local Token="${Src%%${Sep}*}"
		DBGN 5 "  first token: '${Token}'"
		Tokens=( "${Sep}${Token}" )
		Src="${Src#${Token}}"
		while [[ -n "$Src" ]]; do
			# first character now is a separator
			Src="${Src#${Sep}}"
			Token="${Src%%${Sep}*}"
			DBGN 5 "  found another: '${Token}'"
			Tokens+=( "${Sep}${Token}" )
			Src="${Src#${Token}}"
		done
	fi
	local -i NTokens="${#Tokens[@]}"
	DBGN 4 "  => ${NTokens} tokens found"
	local -a Result
	for (( ; NTokens < N ; ++NTokens )); do
		Result+=( "$Sep" )
	done
	Result+=( "${Tokens[@]}" )
	DBGN 3 "Split resulted in ${#Result[@]} items: $(declare -p Result)"
	echo "${Result[@]}"
} # SplitAt()

function ParseIPoverride() {
	# prints an array, first element being IP4, IP6 or {,IP4-,IP6-}ERROR,
	# all others being a character (':' or '.') followed by an optional
	# piece of address, from the most significant to the least one
	local IP="$1"
	local -a Result
	local -i Max
	if isIP4 "$IP" ; then
		Max=4
		Result=( 'IP4' $(SplitAt '.' "$Max" "$IP") )
	elif isIP6 "$IP" ; then
		Max=8
		Result=( 'IP6' $(SplitAt ':' "$Max" "$IP") )
	else
		Max=0
		Result=( 'ERROR' )
	fi
	local res=0
	[[ "${#Result[@]}" -gt $((Max + 1)) ]] && Result[0]="${Result[0]}-ERROR"
	echo "${Result[*]}"
	[[ "${Result[0]//ERROR}" == "${Result[0]}" ]]
} # ParseIPoverride()

function ResolveIP() {
	local Host="$1"
	resolveip -s "$Host"
} # ResolveIP()

function OverrideIP() {
	local Host="$1"
	local HostIP="$(ResolveIP "$Host")"
	[[ -n "$HostIP" ]] || FATAL 1 "Failed to retrieve the IP address of host '${Host}'"
	DBGN 2 "Host '${Host}' => ${HostIP}"

	local HostIPtokens=( $(ParseIPoverride "$HostIP") )
	[[ -n "${HostIPtokens[0]}" ]] || FATAL 1 "Failure to parse ${Host} IP ${HostIP}"
	[[ "${HostIPtokens[0]}" =~ ERROR ]] && FATAL 1 "Failure to parse ${Host} IP ${HostIP} (${HostIPtokens[0]})"

	[[ "${HostIPtokens[0]}" == "${IPOverride[0]}" ]] || FATAL 1 "Host ${Host} returned IP ${HostIP} (${HostIPtokens[0]}), but override is specified as ${IPOverride[0]}."

	local -ri SepSize=1
	local OverriddenIP
	local -i N="${#HostIPtokens[@]}"
	local -i i
	for (( i = 1; i < N ; ++i )); do
		local Token="${HostIPtokens[i]}"
		local OverriddenToken="${IPOverride[i]}"
		[[ "${#OverriddenToken}" -gt $SepSize ]] && Token="$OverriddenToken"
		OverriddenIP+="$Token"
	done
	echo "${OverriddenIP:${SepSize}}"
} # OverrideIP()


################################################################################
###
### parameter parser
###

function parse_options_common() {
	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a common option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		case "$Param" in

			# verbosity options
			( "--fake" )          FAKE=1 ;;
			( "--debug" )         DEBUG=1 ;;
			( "--debug="* )       DEBUG="${Param#--*=}" ;;
			( "--verbose" )       let ++VERBOSE ;;
			( "--quiet" )         let ++QUIET ;;

			# SSH options
			( "--user="* )        RemoteUser="${Param#--*=}" ;;
			( "--asuser="* )      AsRemoteUser="${Param#--*=}" ;;
			( "--nouser" )        NoAsRemoteUser=1 ;;
			( "--server="* | '--host='* )
			                      RemoteHost="${Param#--*=}" ;;
			( "--domain="* )      RemoteDomain="${Param#--*=}" ;;
			( "--ip="* )          IPOverride=( $(ParseIPoverride "${Param#--ip=}") ) ;;
			( "--sshopt="* )      ssh_options+=( "${Param#--*=}" ) ;;
			( "--sshfullopt="* )  ssh_options+=( '-o' "${Param#--*=}" ) ;;
			( "--nodefopts="* )   NoDefaultSSHoptions=1 ;;
			( "--autohost" )      AutoHost+=( 'sshell' ) ;;
			( "--autohost="* )    AutoHost+=( "${Param#--*=}" ) ;;
			( "--hostprefix="* )  RemoteHostPrefix="${Param#--*=}" ;;
			( "--hostsuffix="* )  RemoteHostSuffix="${Param#--*=}" ;;
			( "--jump="* | '--hop=*' )
			                      SSHjumps+=( "${Param#--*=}" ) ;;

			# Kerberos options
			( "--k5realm="* )     KerberosRealm="${Param#--*=}" ;;
			( "--k5user="* )      KerberosUser="${Param#--*=}" ;;
			( "--k5instance="* )  KerberosInstance="${Param#--*=}" ;;
			( "--nonew" )         KerberosNewTicket=0 ;;
			( "--norenew" )       KerberosRenewTicket=0 ;;
			( "--noticket" )      KerberosNewTicket=0 ; KerberosRenewTicket=0 ;;
			( "--k5lifetime=" )   KerberosTicketLifetime="${Param#--*=}" ;;
			( "--k5renewtime=" )  KerberosTicketRenewTime="${Param#--*=}" ;;
			( "--notrenewable" )  KerberosTicketRenewTime='' ;;
			( "--nat=" )          isNAT=1 ;;
			( * )
				return $(( NDigested - 1 ))
		esac
		break
	done
	return $NDigested
} # parse_options_common()


function parse_options_help() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		# by default, assume we swallow one parameter only
		let ++NDigested

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		case "$Param" in
			( '--help' | '-h' | '-?' ) HelpTopics+=( 'help' ) ;;
			( '--version' | '-V' )     HelpTopics+=( 'version' ) ;;
			( '--ssh' )                HelpTopics+=( 'ssh' ) ;;
			( '--write' | '-w' | 'write' | 'w' ) HelpTopics+=( 'write' ) ;;
			( '--read' | '-r' | 'read' | 'r' )   HelpTopics+=( 'read' ) ;;
			( '--exec' | '-x' | 'exec' | 'x' ) HelpTopics+=( 'exec' ) ;;
			( '--tunnel' | '-T' | 'tunnel' | 't' ) HelpTopics+=( 'tunnel' ) ;;
			( '--proxy' | '--socks' | '-s' | 'proxy' | 's' ) HelpTopics+=( 'proxy' ) ;;

			( * )
				[[ "$MODE" == 'help' ]] && FATAL 1 "No help available on '${Param}'"
				return $(( NDigested - 1 ))
		esac
		break
	done
	return $NDigested
} # parse_options_help()


function parse_options_ssh() {
	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	local VNCPortSpec
	local LocalVNCPort RemoteVNCPort
	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( "--vnc" | "--vnc="* )
					[[ "$Param" == '--vnc' ]] || VNCPortSpec="${Param#--*=}"
					
					RemoteVNCPort="${VNCPortSpec#*:}"
					[[ "$VNCPortSpec" != "$RemoteVNCPort" ]] && LocalVNCPort="${VNCPortSpec%:${RemoteVNCPort}}"
					
					[[ -z "$RemoteVNCPort" ]] && RemoteVNCPort=1
					[[ "$RemoteVNCPort" -le 0 ]] && FATAL 1 "Remote VNC port must be positive (${RemoteVNCPort} requested)."
					[[ "$RemoteVNCPort" -lt 100 ]] && let RemoteVNCPort+=5900
					[[ "$RemoteVNCPort" -le 5900 ]] && FATAL 1 "Remote VNC port can't be 5900 or smaller (${RemoteVNCPort} requested)."
					[[ "$RemoteVNCPort" -ge 6000 ]] && FATAL 1 "Remote VNC port can't be 5600 or larger (${RemoteVNCPort} requested)."
					
					[[ -z "$LocalVNCPort" ]] && LocalVNCPort="$RemoteVNCPort"
					[[ "$LocalVNCPort" -le 0 ]] && FATAL 1 "Local VNC port must be positive ($LocalVNCPort} requested)."
					[[ "$LocalVNCPort" -lt 100 ]] && let LocalVNCPort+=5900
					
					
					DBG "Forwarding local port ${LocalVNCPort} to remote ${RemoteVNCPort} [VNC]"
					ssh_options+=( '-o' "LocalForward ${LocalVNCPort} localhost:${RemoteVNCPort}" )
					;;
				( "--src="* )
					Destinations+=( "$CurrentDestination" )
					Sources+=( "${Param#--*=}" )
					;;
				( "--opt="* )
					DBG "Adding option: ${Param#--*=}"
					TransferOptions+=( "${Param#--*=}" )
					;;
				( * )
					# pass all unknown options through as SSH options
					ssh_options+=( "$Param" )
			esac
		else
			# pass all unknown positional parameters through as SSH options
			ssh_options+=( "$Param" )
		fi
		
		break
	done
	return $NDigested
	
} # parse_options_ssh()


function parse_options_write() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0
	
	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( "--dest="* )
					CurrentDestination="${Param#--*=}"
					: ${DefaultDestination:="$CurrentDestination"}
					;;
				( "--src="* )
					Destinations+=( "$CurrentDestination" )
					Sources+=( "${Param#--*=}" )
					;;
				( "--opt="* )
					DBG "Adding option: ${Param#--*=}"
					TransferOptions+=( "${Param#--*=}" )
					;;
				( "--relative" | "-r" )
					RelativeCopy=1
					;;
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			Destinations+=( "$CurrentDestination" )
			Sources+=( "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_write()

function parse_options_read() { parse_options_write "$@" ; }

function parse_options_exec() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			NoMoreOptions=1
			Command=( "${Command[@]}" "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_exec()

function parse_options_ping() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( * )
					FATAL 1 "Invalid ${MODE} mode option '${Param}'."
			esac
		else
			isFlagUnset NoMoreOptions && NoMoreOptions=1 && continue
			Options=( "${Options[@]}" "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_ping()


function init_parameters_tunnel() {
	DBGN 3 "Initializing default parameters for '${MODE}' mode"

	TunnelSpecPattern='^(([0-9]+)(=>|->))?(([^:]*):)?([0-9]+)$'

	TunnelTargetSpecs=( )
	GoToBackground=0
	Command=( )
} # init_parameters_tunnel()


function parse_options_tunnel() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( '--openport='* )        LocalPort="${Param#--*=}" ;;
				( '-P' )   let ++iParam ; LocalPort="${!iParam}" ;;
				( '--background' | '-f' ) GoToBackground=1 ;;
				( '--pid='* )             PIDFile="${Param#--*=}" ;;
				( * )
					FATAL 1 "Invalid ${MODE} mode option '${Param}'."
			esac
		else
			NoMoreOptions=1
			[[ "$Param" =~ $TunnelSpecPattern ]]
			DBGN 1 "Positional parameter: '${Param}' => ${NoMoreTunnelSpecs:+"enough tunnel specifications: ${NoMoreTunnelSpecs}; "} already ${#TunnelTargetSpecs[@]} specs; $(declare -p BASH_REMATCH)}"
			if isFlagUnset NoMoreTunnelSpecs && ( [[ "${#TunnelTargetSpecs[@]}" == 0 ]] || [[ "$Param" =~ $TunnelSpecPattern ]] ) ; then
				TunnelTargetSpecs+=( "$Param" )
			else
				NoMoreTunnelSpecs=1
				Command+=( "$Param" )
			fi
		fi

		break
	done

	return $NDigested
} # parse_options_tunnel()


function init_parameters_proxy() {
	DBGN 3 "Initializing default parameters for '${MODE}' mode"
	
	UseCompression="$DefaultCompressComm"
	GoBackground=0
	LocalPort="$DefaultSOCKS5port"
	LocalHostBind='localhost'
} # init_parameters_proxy()


function parse_options_proxy() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( '--background' )   GoBackground=1 ;;
				( '--compression' )  UseCompression=1 ;;
				( '--nocompression') UseCompression=0 ;;
				( '--port='* )       LocalPort="${Param#--*=}" ;;
				( '--localhost='* )  LocalHostBind="${Param#--*=}" ;;
				( * )
					FATAL 1 "Invalid ${MODE} mode option '${Param}'."
			esac
		else
			isFlagUnset NoMoreOptions && NoMoreOptions=1 && continue
			Options=( "${Options[@]}" "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_proxy()


function parse_options_mount() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( "--remotedir="* )
					Sources=( "${Param#--*=}" )
					;;
				( "--basedir="* )
					BaseMountPoint="${Param#--*=}"
					;;
				( "--refresh" | "--reconnect" )
					Options=( "${Options[@]}" '-o' 'reconnect' )
					;;
				( "--remount" )
					DoRemount=1
					;;
				( "--force" | "-f" )
					ForceMount=1
					;;
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			isFlagUnset NoMoreOptions && NoMoreOptions=1 && continue
			if [[ "${Param:0:1}" == '-' ]]; then
				Options=( "${Options[@]}" "$Param" )
			else
				[[ "${#Destinations[@]}" == 0 ]] || FATAL 1 "Too many mount points specified ('${Param}')."
				Destinations=( "$Param" )
			fi

		fi

		break
	done
	return $NDigested
} # parse_options_mount()


function parse_options_umount() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( "--remotedir="* )
					Sources=( "${Param#--*=}" )
					;;
				( "--force" | "-f" )
					ForceMount=1
					;;
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			isFlagUnset NoMoreOptions && NoMoreOptions=1 && continue
			if [[ "${Param:0:1}" == '-' ]]; then
				Options=( "${Options[@]}" "$Param" )
			else
				FATAL 1 "Unexpected argument ('${Param}')."
			fi

		fi

		break
	done
	return $NDigested
} # parse_options_umount()


function set_environment() {
	# Sets the environment for the specified mode
	local Mode="$1"

	local SetEnvironmentProc="set_environment_${Mode}"

	DBGN 1 "Setting environment for mode '${Mode}'"

	# start from a default environment
	set_default_environment

	declare -f "$SetEnvironmentProc" >& /dev/null
	if [[ $? != 0 ]]; then
		DBGN 2 "No specific environment found."
		return
	fi

	"$SetEnvironmentProc"

} # set_environment()

function set_default_environment() {
	# sets variables for a generic environment

	KerberosNeeded=1
	NoAsRemoteUser=0

	# whether the needed authentication is confirmed to be available
	ConfirmedAuthentication=0

} # set_default_environment()

function set_environment_ping() {
	DBGN 2 "Setting the environment for ping mode."

	# Kerberos is not needed to ping the server:
	KerberosNeeded=0

} # set_environment_ping()


declare MODE=""
declare -i NoMoreOptions=0

declare -i DEBUG=0 QUIET=0 VERBOSE=0 FAKE=0

declare RemoteUser="$USER" RemoteHost='' RemoteDomain=''
declare RemoteHostPrefix='' RemoteHostSuffix=''
declare -a AutoHost
declare -a SSHjumps
declare -i NoDefaultSSHoptions=0

declare KerberosRealm='' KerberosUser="" KerberosInstance=''
declare KerberosTicketLifetime='1d' KerberosTicketRenewTime='7d'
declare -i KerberosTicketForward=1
declare -i KerberosNewTicket=1 KerberosRenewTicket=1 isNAT=0

declare -a Sources Destinations Command
declare -i nSources=0
declare CurrentDestination='' DefaultDestination=''
declare -a ssh_options

declare -i iParam=0 nParams=$#
while [[ $iParam -lt $nParams ]]; do
	let ++iParam
	Param="${!iParam}"

	DBGN 2 "Parsing parameter: '${Param}'"

	if isFlagUnset NoMoreOptions ; then

		# is this the marker of no more options?
		if [[ "$Param" == '--' ]] || [[ "$Param" == '-' ]]; then
			NoMoreOptions=1
			continue
		fi

		# if mode has not been set yet, give it a try
		if [[ -z "$MODE" ]]; then
			case "$Param" in
				( '--help' | '-h' | '-?' | 'help' )    SetOperationMode 'help' ;;
				( '--version' | '-V' | 'version' )     SetOperationMode 'version' ;;
				( '--ssh' | 'ssh' )                    SetOperationMode 'ssh' ;;
				( '--write' | '-w' | 'write' | 'w' )   SetOperationMode 'write' ;;
				( '--read' | '-r' | 'read' | 'r' )     SetOperationMode 'read' ;;
				( '--exec' | '-x' | 'exec' | 'x' )     SetOperationMode 'exec' ;;
				( '--ping' | '-p' | 'ping' | 'p' )     SetOperationMode 'ping' ;;
				( '--tunnel' | '-T' | 'tunnel' | 'T' ) SetOperationMode 'tunnel' ;;
				( '--proxy' | '--socks' | '-s' | 'proxy' | 's' ) SetOperationMode 'proxy' ;;
				( '--mount' | '-m' | 'mount' | 'm' )   SetOperationMode 'mount' ;;
				( '--umount' | '-u' | 'umount' | 'u' ) SetOperationMode 'umount' ;;
				( '--unmount' | 'unmount' )            SetOperationMode 'umount' ;;
			esac
			[[ -n "$MODE" ]] && continue
		fi

		# special option (includes a mode set):
		case "$Param" in
			( '--help='* )
				SetOperationMode 'help'
				HelpTopics=( "${HelpTopics[@]}" "${Param#--*=}" )
				continue
				;;
		esac

		# parse the common options
		parse_options_common "$iParam" "$@"
		HandledParameters=$?
		if [[ "$HandledParameters" -ge 1 ]]; then
			# we have handled some parameters, let's skip them
			let iParam+=${HandledParameters}-1
			continue
		fi
	fi

	# mode-specific options (valid only if a mode is specified)
	if [[ -n "$MODE" ]]; then
		parse_options_${MODE} "$iParam" "$@"
		HandledParameters=$?
		if [[ "$HandledParameters" -ge 1 ]]; then
			# we have handled some parameters, let's skip them
			let iParam+=${HandledParameters}-1
			continue
		fi
	fi

done


[[ ${#SSHjumps[@]} -gt 0 ]] && ssh_options+=( "-J$(JoinStrings ',' "${SSHjumps[@]}")" )

isFlagSet NoDefaultSSHoptions || ssh_options=( "${ssh_default_options[@]}" "${ssh_options[@]}" )
nSources="${#Sources[@]}"

: ${MODE:='ssh'}

isFlagSet QUIET && VERBOSE=0
: ${KerberosUser:="$RemoteUser"}



################################################################################
### Simple operational modes
###

case "$MODE" in
	( 'help' )
		if [[ "${#HelpTopics[*]}" == 0 ]]; then
			help | less -F
		else
			for HelpTopic in "${HelpTopics[@]}" ; do
				help_${HelpTopic}
				LASTFATAL "Error while printing help on topic '${HelpTopic}'"
			done | less -F
		fi
		exit $?
		;;
	( 'version' )
		RealName="$(basename "$(readlink -f "$0")")"
		if [[ "$RealName" == "${SCRIPTNAME}" ]]; then
			echo "${SCRIPTNAME} version ${SCRIPTVERSION}"
		else
			echo "${SCRIPTNAME} (alias of ${RealName}) version ${SCRIPTVERSION}"
		fi
		exit 0
		;;
esac


################################################################################
### Arrange SSH options
###

if [[ -z "$RemoteHost" ]] && [[ ${#AutoHost[@]} -gt 0 ]] ; then
	RemoteHost="$SCRIPTNAME"
	DBG "Using '${RemoteHost}' as host name (unless in ${AutoHost[@]})."
	for ScriptName in "${AutoHost[@]}" ; do
		[[ "$RemoteHost" == "$ScriptName" ]] || continue
		DBG "Host name '${RemoteHost}' is actually a script name."
		unset RemoteHost
		break
	done
fi

[[ -n "$RemoteHost" ]] || FATAL 1 "Remote host specification is required."


# RemoteHostName is the simple host name (no domain/DNS name)
declare RemoteHostName="${RemoteHost%%.*}"

DBGN 2 "Detected remote host: '${RemoteHost}'"
DBGN 3 "Base host name:       '${RemoteHostName}'"
DBGN 3 "Domain name:          '${RemoteDomain}'"

# RemoteDomainFromHostName is the rest of the host specification (no trailing . though)
declare RemoteDomainFromHostName="${RemoteHost#${RemoteHostName}.}"
[[ "$RemoteDomainFromHostName" == "$RemoteHost" ]] && RemoteDomainFromHostName=''
DBGN 3 "Embedded domain name: '${RemoteDomainFromHostName}'"

# rework the host name
[[ "${RemoteHostName#${RemoteHostPrefix}}" == "$RemoteHostName" ]] && RemoteHostName="${RemoteHostPrefix}${RemoteHostName}"
[[ "${RemoteHostName%${RemoteHostSuffix}}" == "$RemoteHostName" ]] && RemoteHostName+="${RemoteHostSuffix}"

DBGN 2 "Complete host name:   '${RemoteHostName}'"

# RemotePath is the fully qualified host + domain name
declare RemotePath="${RemoteHostName}${RemoteDomainFromHostName:+.${RemoteDomainFromHostName}}"
[[ -n "$RemoteDomain" ]] && [[ -z "$RemoteDomainFromHostName" ]] && RemotePath+=".${RemoteDomain}"

DBGN 3 "Complete host path:   '${RemotePath}'"

declare RemoteHostID="$RemotePath"
if [[ -n "${IPOverride[0]}" ]]; then
	RemoteHostIP=$(OverrideIP "$RemotePath")
	LASTFATAL "aborting."
	if [[ -n "$RemoteHostIP" ]]; then
		RemoteHostID="$RemoteHostIP"
		DBGN 2 "Overridden host IP: ${RemoteHostIP}"
		MSG "Overriding remote host ${RemotePath} as ${RemoteHostID}"
	fi
fi


if [[ -n "$AsRemoteUser" ]]; then
	: ${KerberosInstance:="$AsRemoteUser"}
	: ${KerberosUser:="$RemoteUser"}
elif isFlagSet NoAsRemoteUser ; then
	AsRemoteUser=''
else
	AsRemoteUser="$RemoteUser"
fi

declare RemoteFullPath="${AsRemoteUser:+${AsRemoteUser}@}${RemoteHostID}"
DBGN 2 "Complete user path:   '${RemoteFullPath}'"

set_environment "$MODE"


################################################################################
### Get a Kerberos ticket as needed
###

if isFlagUnset KerberosNeeded ; then
	DBGN 1 "No Kerberos authentication is needed."
	ConfirmedAuthentication=1
elif [[ -n "$KerberosRealm" ]]; then

	ConfirmedAuthentication=0
	declare -i GotKerberosTicket=0

	KerberosUserInstance="${KerberosUser}${KerberosInstance:+/${KerberosInstance}}"
	KerberosFullUser="${KerberosUserInstance}@${KerberosRealm}"

	DBGN 1 "Preparing for Kerberos authentication as: '${KerberosFullUser}'"

	# first try to renew an existing ticket
	if isFlagUnset GotKerberosTicket && isFlagSet KerberosRenewTicket ; then
		DBGN 2 " - attempt to renew any existing ticket"
		Execute --mute $kinit -R "$KerberosFullUser" && GotKerberosTicket=1
	else
		DBGN 2 " (no attempt to renew any existing ticket)"
	fi

	if isFlagUnset GotKerberosTicket && isFlagSet KerberosNewTicket ; then

		DBGN 2 " - attempt to obtain a new ticket"
		declare -a KerberosOptions=(
			${KerberosTicketForward:+"-f"}
			${KerberosTicketLifetime:+"-l${KerberosTicketLifetime}"}
			${KerberosTicketRenewTime:+"-r${KerberosTicketRenewTime}"}
		)
		isFlagSet isNAT && KerberosOptions=( "${KerberosOptions[@]}" '-n' )

		echo "Getting a new Kerberos5 ticket: prepare your password."
		Execute $kinit "${KerberosOptions[@]}" "$KerberosFullUser" && GotKerberosTicket=1
	else
		DBGN 2 " (no attempt to obtain a new ticket)"
	fi

	ConfirmedAuthentication="$GotKerberosTicket"
	if isFlagUnset GotKerberosTicket ; then
		ERROR "Couldn't get a new Kerberos5 ticket. Hope there is a valid, existing one."
	fi

else
	DBGN 1 "No Kerberos authentication was requested."
fi


################################################################################
### SSH communication modes
###
declare -i ExitCode=0
case "$MODE" in
	#############################################################################
	( 'ssh' )
		Execute $ssh ${AsRemoteUser:+-l "$AsRemoteUser"} "${ssh_options[@]}" "$RemoteHostID"
		ExitCode=$?
		;;

	#############################################################################
	( 'read' | 'write' )
		# if no destination was ever explicitly specified, assume that the latest
		# parameter is the destination for all the sources;
		# if there is only one source, then assume the destination is the default
		# directory SSH lands to
		
		if isFlagSet RelativeCopy ; then
			
			# all parameters are left as sources
			
			# if we are reading from remote we don't know the home directory in there
			if [[ "$MODE" == 'read' ]]; then
				SourceHome=''
				DestHome="$HOME"
			else 
				SourceHome="$HOME"
				DestHome=''
			fi
			
			for (( iSource=0 ; iSource < $nSources; ++iSource )); do
				
				Source="${Sources[iSource]}"
				DestSpec="${Destinations[iSource]}"
				
				DBGN 3 "Expanding source [$((iSource+1))/${nSources}] '${Source}' (destination: '${DestSpec}')"
				
				Source="$(makeAbsolutePath "$Source")"
				[[ "$MODE" == 'read' ]] && startsWithDir "$Source" "$HOME" && Source="${Source#${HOME}}" && Source="${Source#\/}"
				
				SourceName="$(basename "$Source")"
				SourceDir="$(dirname "$Source")"
				Dest="$SourceDir"
				
				# if the source starts with the home directory, we remove it and make it
				# relative (that will trigger the correct treatment later)
				if [[ -n "$SourceHome" ]] && startsWithDir "$SourceDir" "$SourceHome" ; then
					Dest="${SourceDir:${#SourceHome}+1}"
				fi
				
				[[ -n "$DestSpec" ]] && Dest="${DestSpec}${Dest:+"/${Dest}"}"
				[[ -n "$DestHome" ]] && Dest="$(makeAbsolutePath "$Dest" "$DestHome")"
				
				Sources[iSource]="${SourceDir:+"${SourceDir}/"}${SourceName}"
				Destinations[iSource]="$Dest"
				DBGN 3 "  expanded source [$((iSource+1))/${nSources}]: '${Sources[iSource]}' => '${Destinations[iSource]}'"
				
			done
		elif [[ -z "$DefaultDestination" ]]; then
			if [[ $nSources -gt 1 ]]; then
				let --nSources
				DefaultDestination="${Sources[$nSources]}"
				unset Sources[$nSources]
				unset Destinations[$nSources]
			else
				DefaultDestination='.'
			fi
		fi

		[[ $nSources == 0 ]] && FATAL 1 "In ${MODE} mode, at least one source must be specified!"

		declare -i nErrors=0
		declare -i iSource=0
		while [[ $iSource -lt $nSources ]] ; do
			# accumulate sources to be copied into the same destination
			declare -a TheseSources=( )

			declare ThisDestination="${Destinations[iSource]:-${DefaultDestination}}"
			while [[ "${Destinations[iSource]:-${DefaultDestination}}" == "$ThisDestination" ]]; do
				TheseSources=( "${TheseSources[@]}" "${Sources[iSource]}" )

				let ++iSource
				[[ $iSource -ge $nSources ]] && break
			done

			# -r: recursive directory copy; -p: preserve attributes
			if [[ "$MODE" == 'write' ]]; then
				FullDestination="${RemoteFullPath}:${ThisDestination}"
				TransferData "$FullDestination" "${TheseSources[@]}"
			else
				FullDestination="$ThisDestination"
				declare -a FullSources=( )
				for Source in "${TheseSources[@]}" ; do
					FullSources=( "${FullSources[@]}" "${RemoteFullPath}:${Source}" )
				done
				if [[ "${#FullSources[@]}" -gt 1 ]] || [[ "${FullDestination: -1}" == '/' ]]; then
					Execute $mkdir -p "$FullDestination"
				fi
				TransferData "$FullDestination" "${FullSources[@]}"
			fi
			ExitCode=$?
			if [[ $ExitCode != 0 ]]; then
				ERROR "Copy to '${FullDestination}' failed!"
				let ++nErrors
			fi
		done
		exit $nErrors
		;;

	#############################################################################
	( 'exec' )
		Execute $ssh ${AsRemoteUser:+-l "$AsRemoteUser"} "${ssh_options[@]}" "$RemoteHostID" "${Command[@]}"
		ExitCode=$?
		;;

	#############################################################################
	( 'tunnel' )
		TunnelTargetHost='localhost' # default
		
		# parse target
		[[ "${#TunnelTargetSpecs[@]}" -gt 0 ]] || FATAL 1 "No target of tunnel specified."
		
		declare -a Tunnels=()
		for TunnelTargetSpec in "${TunnelTargetSpecs[@]}" ; do
			[[ "$TunnelTargetSpec" =~ $TunnelSpecPattern ]] || FATAL 1 "Target specification '${TunnelTargetSpec}' not valid (format: \`localport=>[host:]port\`)."
			TunnelTargetHost="${BASH_REMATCH[5]:-"localhost"}"
			TunnelTargetPort="${BASH_REMATCH[6]}"
			TunnelTargetLocalPort="${BASH_REMATCH[2]:-"$TunnelTargetPort"}"
			Tunnels+=( '-L' "${TunnelTargetLocalPort}:${TunnelTargetHost}:${TunnelTargetPort}" )
		done
		TunnelOptions=( "${Tunnels[@]}" -o 'ExitOnForwardFailure yes' -o 'TCPKeepAlive yes' -o 'ServerAliveInterval 15' )
		[[ "${#Command[@]}" == 0 ]] && TunnelOptions+=( '-N' ) && GoToBackground=1
		isFlagSet GoToBackground && TunnelOptions+=( '-f' )
		isIP6 "$TunnelTargetHost" || TunnelOptions+=( '-4' )
		Execute $ssh -l "$RemoteUser" "${ssh_options[@]}" "${TunnelOptions[@]}" "$RemoteHostID" "${Command[@]}"
		ExitCode=$?
		;;

	#############################################################################
	( 'proxy' )
		ProxyOptions=( '-D' "${LocalHostBind:+"${LocalHostBind}:"}${LocalPort}"
		  '-N' # execute no command
		  '-T' # no pseudo-terminal
		  $(ifFlagSet UseCompression '-C')
		  $(ifFlagSet GoBackground '-f')
		  ${BackgroundOpt}
		  '-o' 'ServerAliveInterval=30'
		  '-o' 'ExitOnForwardFailure=yes'
		  '-o' 'StrictHostKeyChecking=no'
		  )
		echo "Opening SOCKS5 proxy (port ${LocalPort}) to ${RemoteHostID}..."
		Execute $ssh -l "$RemoteUser" "${ProxyOptions[@]}" "$RemoteHostID"
		# some feedback... we don't know the PID of SSH unfortunately
		[[ $ExitCode == 0 ]] && ifFlagSet GoBackground "Done."
		ExitCode=$?
		;;

	#############################################################################
	( 'ping' )
		Execute $ping "${Options[@]}" -- "$RemoteHostID"
		ExitCode=$?
		;;

	#############################################################################
	( 'mount' )
		SetMountPoint "${Destinations[0]}"

		if isFlagUnset ConfirmedAuthentication && isOSX ; then

			# on OSX sshfs is fragile and attempting to use it with no valid
			# authentication makes the OS unstable.
			FATAL 1 "Remote mounting NOT attempted: make sure authentication succeeds and then try again."

		fi

		Execute $mkdir -p "$MountPoint"
		LASTFATAL 1 "Can't write the mount point '${MountPoint}'"

		if isFlagSet DoRemount ; then
			# this is quite crude...
			Unmount "$MountPoint" # "$ForceMount"
			res=$?
			[[ $res != 0 ]] && DBGN 2 "umount failed with exit code ${res}. Ignoring."
		fi

		RemoteDir="${RemoteHostID}:${Sources[0]}"

		Execute $sshfs "$RemoteDir" "$MountPoint" -o follow_symlinks "${Options[@]}"
		ExitCode=$?
		if [[ $ExitCode == 0 ]]; then
			MSG "'${RemoteDir}' mounted at '${MountPoint}'. Unmount with \`fusermount -u '${MountPoint}'\`."
		else
			# attempt to clean up the residual of the mount, but leave the mount directory there
			Unmount "$MountPoint"
			res=$?
			[[ $res != 0 ]] && DBGN 2 "Cleanup umount failed with exit code ${res}. Too bad."
		fi
		;;

	#############################################################################
	( 'umount' )
		SetMountPoint "${Destinations[0]}"
		Unmount "$MountPoint"
		;;

	#############################################################################
	( * ) FATAL 1 "Unknown SSH operation '${MODE}'." ;;
esac


exit $ExitCode
