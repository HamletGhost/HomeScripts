#!/bin/bash
#
# Run with --help for help.
# Host name can be retrieved from the name of the script (also in case the
# script is actually a symbolic link).
#
# Script versions:
# < 1.0: developement versions
# 1.0 (petrillo@fnal.gov, 20141004)
#     tested long enough to have it official
# 1.1 (petrillo@fnal.gov, 20141004)
#     added --asuser option
# 1.2 (20141114, petrillo@fnal.gov)
#   added exec option
# 1.3 (20150830, petrillo@fnal.gov)
#   added "ping" mode
# 1.4 (20161227, petrillo@fnal.gov)
#   added "mount" mode
# 1.5 (20161228, petrillo@fnal.gov)
#   added "umount" mode
# 1.6 (20170303, petrillo@fnal.gov)
#   added forced unmount option
# 1.7 (20170811, petrillo@fnal.gov)
#   login name not passed any more by default
# 1.8 (20171202, petrillo@fnal.gov)
#   added --ip option
# 1.9 (20190820, petrillo@slac.stanford.edu)
#   added tunnel mode
# 1.10 (20190826, petrillo@slac.stanford.edu)
#   changes the tunnel mode to support multiple tunnels on the same connection;
#   also fixed tunnel mode help
# 1.11 (20200303, petrillo@slac.stanford.edu)
#   added awareness of whether authentication is confirmed valid, and some
#   behaviour depending on that
#

SCRIPTNAME="$(basename "$0")"
SCRIPTDIR="$(dirname "$0")"
CWD="$(pwd)"

SCRIPTVERSION="1.11"

# program paths
: ${kinit:="kinit"}
: ${ssh:="ssh"}
: ${mkdir:="mkdir"}
: ${ping:="ping"}
: ${sshfs:="sshfs"}

ssh_default_options=( '-X' )
# ssh_default_options=( '-X' '-Y' )
transfer_default_options=( '--verbose' '--archive' )

declare -r DefaultBaseMountPoint="${HOME}/Volumes"


function help() {
	cat <<-EOH
	Operates on a remote server via SSH.

	Usage:  ${SCRIPTNAME}  [options] [--] [parameters]

	The script operates in one of the following modes, specified as options:

	--ssh [default]
	    opens an iterative shell on the remote host
	--read , -r , read , r
	    copies the specified files from a directory in the remote server into
	    the current directory
	--write , -w , write , w
	    writes the specified files into a directory in the remote server
	--exec , -x , exec , x
	    executes a command on the remote host
	--ping , -p , ping , p
	    executes ping with the specified parameters
	--mount , -m , mount , m
	    mounts the remote directory into the specified one
	--umount , -u , umount , u
	    unmounts the remote directory previously mounted with the 'mount' mode
	--version , -V
	    just prints the version numbre and exits
	--help , -h , -?
	    just prints this help message and exits

	Each mode can have its specific options, in addition to commonly accepted
	ones:

	EOH
	help_common
} # help()


function help_common() {
	cat <<-EOH
	Verbosity options:
	--fake
	    only writes the commands it would execute (usually assumes they succeed)
	--debug[=LEVEL]
	    enables debugging output
	--verbose
	    increases the verbosity of the program (e.g. prints the commands it
	    executes)
	--quiet
	    decreases the verbosity of the command

	SSH options:
	--user=REMOTEUSER [${USER}]
	    uses this user for remote log in
	--asuser=ASREMOTEUSER [as REMOTEUSER]
	    uses this user for remote log in, but still uses REMOTEUSER above in the
	    authentication (see below)
	--nouser
	    do not specify the user (ASREMOTEUSER above); count on SSH to know better
	--host=HOSTNAME
	    the name of the SSH server to be contacted
	--domain=DOMAIN
	    if specified, it is appended to the host name unless the latter already
	    includes a domain
	--ip=IP4ADDRESS
	    after resolving the remote host IP, replaces the lowest IP4 bytes with
	    the specified ones; for example, on a host resolving to 192.168.1.1,
	    \`--ip=129.3\` will result in a target host IP of 192.168.129.3
	--autohost[=ScriptName]
	    if no host name is specified, it uses the script name as host name,
	    unless the script name matches ScriptName; if ScriptName is omitted,
	    'sshell' is used. This option can be specified multiple times to exclude
	    multiple script names
	--hostprefix=PREFIX
	    prepends PREFIX to the host name
	--hostsuffix=SUFFIX
	    appends SUFFIX to the host name

	Kerberos authentication options (see \`man 1 kinit\` for details):
	--k5realm=KRB5REALM
	--k5user=KRB5USER [as ASREMOTEUSER, or REMOTEUSER]
	--k5instance=KRB5USERINSTANCE [as ASREMOTEUSER, or not used]
	    if a Kerberos5 realm is specified, a ticket will be obtained from that
	    realm, using KRB5USER as user (by default, the same as --remote option)
	    and an optional instance KRB5USERINSTANCE (e.g. 'root' for administration
	    privileges)
	--nonew
	    do not attempt to get a new Kerberos ticket (can still renew an existing
	    one)
	--norenew
	    do not attempt to renew an existing ticket (can still obtain a new one)
	--noticket
	    do not attempt to get a Kerberos ticket at all (equivalent to
	    options --nonew and --norenew together)
	--k5lifetime=LIFETIME ['${KerberosTicketLifetime}']
	    when requesting a new ticket, ask it to last for lifetime (it may still
	    be renewed beyond it)
	--k5enewtime=RENEWTIME ['${KerberosTicketRenewTime}']
	    when requesting a new ticket, ask to allow it to be renewed up to
	    RENEWTIME time (in total)
	--notrenewable
	    requested Kerberos ticket is not renewable
	EOH
} # help_common()


function help_help() {
	cat <<-EOH
	Mode: help

	  ${SCRIPTNAME}  <--help[=Mode]|-h|-?>

	Prints help about this script, or about its specified mode if Mode is
	specified.

	EOH
} # help_help()


function help_version() {
	cat <<-EOH
	Mode: version

	  ${SCRIPTNAME}  <--version|-V>

	Prints the version of this script.

	EOH
} # help_version()


function help_read() {
	cat <<-EOH
	Mode: read
	  ${SCRIPTNAME}  <--read|-r|read|r> [options]
	    [--dest=DEST] source [source ...]
	    [--dest=DEST source [source ...]]
	  ${SCRIPTNAME}  <--read|-r|read|r> [options] [--]
	    source [source ...] [destination]

	Reads the specified remote files into the local host.
	If a relative source path is specified, it is relative to the directory where
	ssh lands (typically, user's home directory).
	Each destination option (below) refers to the following sources, up to the
	next destination option.
	The sources before the first destination option (if any) are copied to the
	first specified destination.
	In the second form, where no destination option is specified, the destination
	for all the source files is the last parameter. If only one parameter is
	present, it is interpreted as a source to be copied to the current directory.

	If the destination can be detected to be a directory, that directory is
	created. A destination is detected as a directory if it is destination for
	multiple sources or if its name ends in '/'.

	Read mode options:
	--src=SOURCE
	    specifies a remote source; alternative way to specify sources.
	    If a relative path is specified, it is relative to the directory where
	    ssh lands (typically, user's home directory)
	--dest=DESTDIR
	    the directory in the local host where to copy the following sources

	In addition, the common options are accepted:

	EOH
	help_common
} # help_read()


function help_write() {
	cat <<-EOH
	Mode: write
	  ${SCRIPTNAME}  <--write|-w|write|w> [options]
	    [--dest=DEST] source [source ...]
	    [--dest=DEST source [source ...]]
	  ${SCRIPTNAME}  <--write|-w|write|w> [options] [--]
	    source [source ...] [destination]

	Writes the specified local files to the remote server.
	Each destination option (below) refers to the following sources, up to the
	next destination option.
	The sources before the first destination option (if any) are copied to the
	first specified destination.
	In the second form, where no destination option is specified, the destination
	for all the source files is the last parameter. If only one parameter is
	present, it is interpreted as a source to be copied to the directory where
	ssh lands on the remote server (".", typically, user's home directory).

	Write mode options:
	--src=SOURCE
	    specifies a source; alternative way to specify sources
	--dest=DESTDIR
	    the directory under the remote host where to copy the following sources;
	    if a relative path is specified, it is relative to the directory where
	    ssh lands (typically, user's home directory)

	In addition, the common options are accepted:

	EOH
	help_common
} # help_write()


function help_exec() {
	cat <<-EOH
	Mode: write
	  ${SCRIPTNAME}  <--exec|-x|exec|x> [options]
	    command [command arguments...]

	Executes the specified command in the remote shell, then returns.

	Execution mode options:
	  no specific one

	In addition, the common options are accepted:

	EOH
	help_common
} # help_exec()


function help_ping() {
	cat <<-EOH
	Mode: ping
	  ${SCRIPTNAME}  <--ping|-p|ping|p> [options] [--] [ping options]

	Executes ping on the server. Arguments are passed to ping.

	Ping mode options:
	  no specific one

	The common options are accepted:

	EOH
} # help_ping()


function help_tunnel() {
	cat <<-EOH
	Mode: tunnel
	  ${SCRIPTNAME}  <--tunnel|-T|tunnel|T> [options] [--] [tunnel options] target [command]

	The target is a remote server plus port specification,
	\`localport=>[remotetarget:]remoteport\`, with \`remotetarget\` being
	"localhost" by default.
	An SSH tunnelling connection is opened to reach each of the specified remote
	targets, from the port \`localport\` on this node (that is,
	\`localhost:localport\`) to the \`remoteport\` port on the \`remotetarget\`
	node, passing through the host${RemoteHost=+" ${RemoteHost}"} as specified in ${SCRIPTNAME} (\`-L\` option).
	If a command is specified, it is executed on the host and the connection is
	closed after the command terminates. Otherwise, an interactive shell is opened
	unless \`--background\` option is specified.

	Tunnel mode options:
	--background , -f
	  if specified, the SSH connection is set in the background

	The common options are accepted:

	EOH
} # help_tunnel()


function help_mount() {
	cat <<-EOH
	Mode: mount
	  ${SCRIPTNAME}  <--mount|mount> [options] [MountPoint] [--] [SSHFS options]

	Mounts a remote directory into the specified one. The additional options are
	passed to SSHFS.
	If no mount point is specified, <BaseMountPoint>/<ServerName> is used
	(<BaseMountPoint> can be specified as an option).

	SSHFS is required.

	Mount mode options:
	--remotedir=REMOTEDIR [default: the remote home directory]
	    mounts the specified remote directory
	--basedir=BASEMOUNTPOINT ['${DefaultBaseMountPoint}']
	    if mount directory is not specified, it's created under this directory
	--remount
	    if the target is already mounted, tries to remount it
	--force , -f
	    tries to push through errors to get the target mounted

	The common options are accepted:

	EOH
} # help_mount()


function help_umount() {
	cat <<-EOH
	Mode: mount
	  ${SCRIPTNAME}  <--umount|umount> [options]

	Unmounts a remote directory that has been mounted before.
	It needs the same remote directory argument as the mount command.

	Mount mode options:
	--remotedir=REMOTEDIR [default: the remote home directory]
	    ummounts the specified remote directory
	--force , -f
	    ask the system to force unmounting

	The common options are accepted (most are just ignored):

	EOH
} # help_umount()


function isFlagSet() {
	local VARNAME="$1"
	[[ -n "${!VARNAME//0}" ]]
}

function isFlagUnset() {
	local VARNAME="$1"
	[[ -z "${!VARNAME//0}" ]]
}

function isFlagOver() {
	local VARNAME="$1"
	local Threshold="${2:-"1"}"
	[[ -n "${!VARNAME}" ]] && [[ "${!VARNAME}" -ge "$Threshold" ]]
}

function STDERR() { echo "$*" >&2 ; }

function STDERRN() { echo -n "$*" >&2 ; }

function ERROR() { STDERR "ERROR: $*" ; }

function FATAL() {
	local Code=$1
	shift
	STDERR "FATAL (${Code}): $*"
	exit $Code
} # FATAL()

function LASTFATAL() {
	local -i ExitCode="$?"
	[[ $ExitCode == 0 ]] || FATAL $ExitCode "$*"
} # LASTFATAL()


function isDebugging() { isFlagOver DEBUG $1 ; }

function DBG() { isDebugging && STDERR "DBG| $*" ; }

function DBGN() {
	local Level="$1"
	shift
	isDebugging $Level && STDERR "DBG[${Level}]| $*"
} # DBGN()

function CMDDBG() {
	isDebugging || return
	for Par in "$@" ; do STDERRN "'${Par}' " ; done
	STDERR ""
} # CMDDBG()

function DUMPVAR() {
	local VarName="$1"
#	DBG "${VarName}='${!VarName}'"
  local Value
  Value="$(declare -p "$VarName" 2> /dev/null)"
  local -i Code=$?
  if [[ "$Code" == 0 ]]; then
    DBG "${Value}"
  else
    DBG "'${VarName}' not defined!"
  fi
} # DUMPVAR()

function DUMPVARS() {
	isDebugging || return
	local VarName
	for VarName in "$@" ; do
		DUMPVAR "$VarName"
	done
} # DUMPVARS()

function isOSX() {
	[[ "$(uname)" == 'Darwin' ]]
}


function MSG() { isFlagSet QUIET || echo "$@" ; }

function FileFromDescriptor() {
	# Prints the file associated to the descriptor
	local -i Descriptor="$1"

	if [[ -d '/proc' ]]; then
		# lucky us, there is procfs
		local FD="/proc/${$}/fd/0"
		[[ -e "$FD" ]] || return 1 # but there is no such file descriptor!
		readlink "$FD"
		return 0
	else
		case "$Descriptor" in
			( * ) return 1 ;;
		esac
	fi
} # FileFromDescriptor()


function SetOperationMode() {
	local Mode="$1"
	if [[ -n "$MODE" ]]; then
		if [[ "$Mode" != "$MODE" ]]; then
			FATAL 1 "Conflicting mode specifications: ${MODE} and ${Mode}"
		else
			STDERR "WARNING: mode '${Mode}' set more than once."
			return
		fi
	fi
	MODE="$Mode"
	local -r ModeParameters="init_parameters_${MODE}"
	declare -f "$ModeParameters" >& /dev/null && "$ModeParameters"

} # SetOperationMode()


function Max() {
	[[ $# -gt 0 ]] || return 1
	local -i Max=$1
	local -i iItem
	for (( iItem = 2 ; iItem <= $# ; ++iItem )); do
		local Item="${!iItem}"
		[[ -z "$Item" ]] && continue
		[[ "$Item" -gt "$Max" ]] && Max="$Item"
	done
	echo "$Max"
	return 0
} # Max()


function RedirectOutput() {
	# Redirects the specified file descriptor to a specified file, and prints
	# the previous one.
	local -i FileDescriptor="$1"
	local RedirectTo="$2"
	[[ -n "$RedirectTo" ]] || return 1

	local ProcHandle="/proc/$$/fd/${FileDescriptor}"
	local OldOutput
	[[ -h "$ProcHandle" ]] && OldOutput="$(readlink "$ProcHandle")"

	local res=0
	exec "${FileDescriptor}>" "$RedirectTo"
	res=$?
	[[ $res == 0 ]] || return $res

	echo "$OldOutput"
	return 0
} # RedirectOutput()


function Execute() {
	local StdIn StdOut StdErr
	while [[ "${1:0:1}" == '-' ]]; do
		case "$1" in
			( '--muteoutput' )
				StdOut="/dev/null"
				;;
			( '--muteerror' )
				StdErr="/dev/null"
				;;
			( '--mute' )
				StdOut="/dev/null"
				StdErr="/dev/null"
				;;
			( '--' )
				shift
				break ;;
			( * )
				break ;;
		esac
		shift
	done

	local -a Command=( "$@" )
	local -i ExitCode=0

	# print the command being run
	if isFlagSet FAKE || isFlagSet VERBOSE || isDebugging ; then
		echo "CMD: ${Command[@]} ${StdIn:+"0< '${StdIn}'"} ${StdOut:+"1> '${StdOut}'"} ${StdErr:+"2> '${StdErr}'"}"
	fi

	# run the command
	if isFlagUnset FAKE ; then
		# establish redirections
		local OldStdIn OldStdOut OldStdErr
		if [[ -n "$StdIn" ]]; then
			OldStdIn="$(FileFromDescriptor 0)"
			if [[ $? == 0 ]]; then
				DBGN 3 "Saving standard input: '${OldStdIn}'"
				exec 0< "$StdIn"
			else
				DBGN 3 "Not muting STDIN since we can't detect where it is directed"
			fi
		fi
		if [[ -n "$StdOut" ]]; then
			OldStdOut="$(FileFromDescriptor 1)"
			if [[ $? == 0 ]]; then
				DBGN 3 "Saving standard output: '${OldStdOut}'"
				exec 1> "$StdOut"
			else
				DBGN 3 "Not muting STDOUT since we can't detect where it is directed"
			fi
		fi
		if [[ -n "$StdErr" ]]; then
			OldStdErr="$(FileFromDescriptor 2)"
			if [[ $? == 0 ]]; then
				DBGN 3 "Saving standard error: '${OldStdErr}'"
				exec 2> "$StdErr"
			else
				DBGN 3 "Not muting STDERR since we can't detect where it is directed"
			fi
		fi

		"${Command[@]}"
		ExitCode=$?
		DBG "Exit code for '${Command[0]}': ${ExitCode}"

		# reset redirections; plenty of bugs if procfs is not availableß
		if [[ -n "$OldStdErr" ]]; then
			exec 2> "$OldStdErr"
			DBGN 3 "Standard error restored to '${OldStdErr}'"
		fi
		if [[ -n "$OldStdOut" ]]; then
			exec 1> "$OldStdOut"
			DBGN 3 "Standard output restored to '${OldStdOut}'"
		fi
		if [[ -n "$OldStdIn" ]]; then
			exec 0< "$OldStdIn"
			DBGN 3 "Standard input restored to '${OldStdIn}'"
		fi


	fi

	return $ExitCode
} # Execute()


function TransferData() {
	#
	# Usage:  TransferData  Destination Sources ...
	#
	local Destination="$1"
	shift
	local -a Sources=( "$@" )
	local -a Options=( "${TransferOptions[@]}" )
	[[ "${#Options[@]}" == 0 ]] && Options=( "${transfer_default_options[@]}" )
	Execute rsync "${Options[@]}" -e ssh "${Sources[@]}" "$Destination"
} # TransferData()


function CheckExecutable() {
  local ExecPath="$1"

  which "$ExecPath" || FATAL 2 "Can't find the required executable '${ExecPath}'."

} # CheckExecutable()


function SetMountPoint() {
	MountPoint="$1"
	: ${BaseMountPoint:="$DefaultBaseMountPoint"}
	: ${MountPoint:="${BaseMountPoint:+${BaseMountPoint%/}/}${RemoteHostID}"}
} # SetMountPoint()


function Mount() {
	if isOSX && ! which fusermount >& /dev/null ; then
		Execute --mute mount "$MountPoint"
	else
		Execute --mute fusermount "$MountPoint"
	fi
}

function Unmount() {
	if isOSX && ! which fusermount >& /dev/null ; then
		Execute --mute umount "$MountPoint"
	else
		Execute --mute fusermount -u "$MountPoint"
	fi
}

function isIP6() {
	local IP="$1"
	[[ -n "IP" ]] && [[ "$IP" =~ ^([0-9A-Fa-f]{1,4})?(:([0-9A-Fa-f]{0,4})){0,7}$ ]]
} # isIP6()

function isIP4() {
	local IP="$1"
	[[ -n "$IP" ]] && [[ "$IP" =~ ^([0-9]{1,3}|[0-9A-Fa-f]{2})?(\.([0-9]{1,3}|[0-9A-Fa-f]{2})?){0,3}$ ]]
} # isIP4()

function SplitAt() {
	local -r Sep="$1"
	local -r N="$2"
	local Src="$3"

	DBGN 4 "Splitting '${Src}' with '${Sep}'"
	local -a Tokens
	if [[ -n "$Src" ]]; then
		local Token="${Src%%${Sep}*}"
		DBGN 5 "  first token: '${Token}'"
		Tokens=( "${Sep}${Token}" )
		Src="${Src#${Token}}"
		while [[ -n "$Src" ]]; do
			# first character now is a separator
			Src="${Src#${Sep}}"
			Token="${Src%%${Sep}*}"
			DBGN 5 "  found another: '${Token}'"
			Tokens+=( "${Sep}${Token}" )
			Src="${Src#${Token}}"
		done
	fi
	local -i NTokens="${#Tokens[@]}"
	DBGN 4 "  => ${NTokens} tokens found"
	local -a Result
	for (( ; NTokens < N ; ++NTokens )); do
		Result+=( "$Sep" )
	done
	Result+=( "${Tokens[@]}" )
	DBGN 3 "Split resulted in ${#Result[@]} items: $(declare -p Result)"
	echo "${Result[@]}"
} # SplitAt()

function ParseIPoverride() {
	# prints an array, first element being IP4, IP6 or {,IP4-,IP6-}ERROR,
	# all others being a character (':' or '.') followed by an optional
	# piece of address, from the most significant to the least one
	local IP="$1"
	local -a Result
	local -i Max
	if isIP4 "$IP" ; then
		Max=4
		Result=( 'IP4' $(SplitAt '.' "$Max" "$IP") )
	elif isIP6 "$IP" ; then
		Max=8
		Result=( 'IP6' $(SplitAt ':' "$Max" "$IP") )
	else
		Max=0
		Result=( 'ERROR' )
	fi
	local res=0
	[[ "${#Result[@]}" -gt $((Max + 1)) ]] && Result[0]="${Result[0]}-ERROR"
	echo "${Result[*]}"
	[[ "${Result[0]//ERROR}" == "${Result[0]}" ]]
} # ParseIPoverride()

function ResolveIP() {
	local Host="$1"
	resolveip -s "$Host"
} # ResolveIP()

function OverrideIP() {
	local Host="$1"
	local HostIP="$(ResolveIP "$Host")"
	[[ -n "$HostIP" ]] || FATAL 1 "Failed to retrieve the IP address of host '${Host}'"
	DBGN 2 "Host '${Host}' => ${HostIP}"

	local HostIPtokens=( $(ParseIPoverride "$HostIP") )
	[[ -n "${HostIPtokens[0]}" ]] || FATAL 1 "Failure to parse ${Host} IP ${HostIP}"
	[[ "${HostIPtokens[0]}" =~ ERROR ]] && FATAL 1 "Failure to parse ${Host} IP ${HostIP} (${HostIPtokens[0]})"

	[[ "${HostIPtokens[0]}" == "${IPOverride[0]}" ]] || FATAL 1 "Host ${Host} returned IP ${HostIP} (${HostIPtokens[0]}), but override is specified as ${IPOverride[0]}."

	local -ri SepSize=1
	local OverriddenIP
	local -i N="${#HostIPtokens[@]}"
	local -i i
	for (( i = 1; i < N ; ++i )); do
		local Token="${HostIPtokens[i]}"
		local OverriddenToken="${IPOverride[i]}"
		[[ "${#OverriddenToken}" -gt $SepSize ]] && Token="$OverriddenToken"
		OverriddenIP+="$Token"
	done
	echo "${OverriddenIP:${SepSize}}"
} # OverrideIP()


################################################################################
###
### parameter parser
###

function parse_options_common() {
	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a common option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		case "$Param" in

			# verbosity options
			( "--fake" )          FAKE=1 ;;
			( "--debug" )         DEBUG=1 ;;
			( "--debug="* )       DEBUG="${Param#--*=}" ;;
			( "--verbose" )       let ++VERBOSE ;;
			( "--quiet" )         let ++QUIET ;;

			# SSH options
			( "--user="* )        RemoteUser="${Param#--*=}" ;;
			( "--asuser="* )      AsRemoteUser="${Param#--*=}" ;;
			( "--nouser" )        NoAsRemoteUser=1 ;;
			( "--server="* | '--host='* )
			                      RemoteHost="${Param#--*=}" ;;
			( "--domain="* )      RemoteDomain="${Param#--*=}" ;;
			( "--ip="* )          IPOverride=( $(ParseIPoverride "${Param#--ip=}") ) ;;
			( "--sshopt="* )      ssh_options=( "${ssh_options[@]}" "${Param#--*=}" ) ;;
			( "--nodefopts="* )   NoDefaultSSHoptions=1 ;;
			( "--autohost" )      AutoHost=( "${AutoHost[@]}" 'sshell' ) ;;
			( "--autohost="* )    AutoHost=( "${AutoHost[@]}" "${Param#--*=}" ) ;;
			( "--hostprefix="* )  RemoteHostPrefix="${Param#--*=}" ;;
			( "--hostsuffix="* )  RemoteHostSuffix="${Param#--*=}" ;;

			# Kerberos options
			( "--k5realm="* )     KerberosRealm="${Param#--*=}" ;;
			( "--k5user="* )      KerberosUser="${Param#--*=}" ;;
			( "--k5instance="* )  KerberosInstance="${Param#--*=}" ;;
			( "--nonew" )         KerberosNewTicket=0 ;;
			( "--norenew" )       KerberosRenewTicket=0 ;;
			( "--noticket" )      KerberosNewTicket=0 ; KerberosRenewTicket=0 ;;
			( "--k5lifetime=" )   KerberosTicketLifetime="${Param#--*=}" ;;
			( "--k5renewtime=" )  KerberosTicketRenewTime="${Param#--*=}" ;;
			( "--notrenewable" )  KerberosTicketRenewTime='' ;;
			( "--nat=" )          isNAT=1 ;;
			( * )
				return $(( NDigested - 1 ))
		esac
		break
	done
	return $NDigested
} # parse_options_common()


function parse_options_help() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		# by default, assume we swallow one parameter only
		let ++NDigested

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		case "$Param" in
			( '--help' | '-h' | '-?' ) HelpTopics=( "${HelpTopics[@]}" 'help' ) ;;
			( '--version' | '-V' )     HelpTopics=( "${HelpTopics[@]}" 'version' ) ;;
			( '--ssh' )                HelpTopics=( "${HelpTopics[@]}" 'ssh' ) ;;
			( '--write' | '-w' | 'write' | 'w' ) HelpTopics=( "${HelpTopics[@]}" 'write' ) ;;
			( '--read' | '-r' | 'read' | 'r' )   HelpTopics=( "${HelpTopics[@]}" 'read' ) ;;
			( '--exec' | '-x' | 'exec' | 'x' ) HelpTopics=( "${HelpTopics[@]}" 'exec' ) ;;
			( '--tunnel' | '-T' | 'tunnel' | 't' ) HelpTopics=( "${HelpTopics[@]}" 'tunnel' ) ;;

			( * )
				[[ "$MODE" == 'help' ]] && FATAL 1 "No help available on '${Param}'"
				return $(( NDigested - 1 ))
		esac
		break
	done
	return $NDigested
} # parse_options_help()


function parse_options_ssh() {
	local -i iParam=$(( $1 - 1 ))
	shift

	local Param="${!iParam}"

	DBGN 3 "  is '${Param}' a ${MODE} option?"

	# accept all the options as SSH options
	ssh_options=( "${ssh_options[@]}" "$Param" )

	return 1
} # parse_options_ssh()


function parse_options_write() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( "--dest="* )
					CurrentDestination="${Param#--*=}"
					: ${DefaultDestination:="$CurrentDestination"}
					;;
				( "--src="* )
					Destinations=( "${Destinations[@]}" "$CurrentDestination" )
					Sources=( "${Sources[@]}" "${Param#--*=}" )
					;;
				( "--opt="* )
               DBG "Adding option: ${Param#--*=}"
					TransferOptions=( "${TransferOptions[@]}" "${Param#--*=}" )
					;;
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			Destinations=( "${Destinations[@]}" "$CurrentDestination" )
			Sources=( "${Sources[@]}" "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_write()

function parse_options_read() { parse_options_write "$@" ; }

function parse_options_exec() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			NoMoreOptions=1
			Command=( "${Command[@]}" "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_exec()

function parse_options_ping() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( * )
					FATAL 1 "Invalid ${MODE} mode option '${Param}'."
			esac
		else
			isFlagUnset NoMoreOptions && NoMoreOptions=1 && continue
			Options=( "${Options[@]}" "$Param" )
		fi

		break
	done
	return $NDigested
} # parse_options_ping()


function init_parameters_tunnel() {
	DBGN 3 "Initializing default parameters for '${MODE}' mode"

	TunnelSpecPattern='^([0-9]+)(=>|->)(([^:]*):)?([0-9]+)$'

	TunnelTargetSpecs=( )
	GoToBackground=0
	Command=( )
} # init_parameters_tunnel()


function parse_options_tunnel() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( '--openport='* )        LocalPort="${Param#--*=}" ;;
				( '-P' )   let ++iParam ; LocalPort="${!iParam}" ;;
				( '--background' | '-f' ) GoToBackground=1 ;;
				( '--pid='* )             PIDFile="${Param#--*=}" ;;
				( * )
					FATAL 1 "Invalid ${MODE} mode option '${Param}'."
			esac
		else
			NoMoreOptions=1
			[[ "$Param" =~ $TunnelSpecPattern ]]
			DBGN 1 "Positional parameter: '${Param}' => ${NoMoreTunnelSpecs:+"enough tunnel specifications: ${NoMoreTunnelSpecs}; "} already ${#TunnelTargetSpecs[@]} specs; $(declare -p BASH_REMATCH)}"
			if isFlagUnset NoMoreTunnelSpecs && ( [[ "${#TunnelTargetSpecs[@]}" == 0 ]] || [[ "$Param" =~ $TunnelSpecPattern ]] ) ; then
				TunnelTargetSpecs+=( "$Param" )
			else
				NoMoreTunnelSpecs=1
				Command+=( "$Param" )
			fi
		fi

		break
	done

	return $NDigested
} # parse_options_tunnel()


function parse_options_mount() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( "--remotedir="* )
					Sources=( "${Param#--*=}" )
					;;
				( "--basedir="* )
					BaseMountPoint="${Param#--*=}"
					;;
				( "--refresh" | "--reconnect" )
					Options=( "${Options[@]}" '-o' 'reconnect' )
					;;
				( "--remount" )
					DoRemount=1
					;;
				( "--force" | "-f" )
					ForceMount=1
					;;
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			isFlagUnset NoMoreOptions && NoMoreOptions=1 && continue
			if [[ "${Param:0:1}" == '-' ]]; then
				Options=( "${Options[@]}" "$Param" )
			else
				[[ "${#Destinations[@]}" == 0 ]] || FATAL 1 "Too many mount points specified ('${Param}')."
				Destinations=( "$Param" )
			fi

		fi

		break
	done
	return $NDigested
} # parse_options_mount()


function parse_options_umount() {

	local -i iParam=$(( $1 - 1 ))
	shift
	local -i NDigested=0

	while [[ $iParam -lt $# ]]; do
		let ++iParam
		local Param="${!iParam}"

		DBGN 3 "  is '${Param}' a ${MODE} option?"

		# by default, assume we swallow one parameter only
		let ++NDigested

		if [[ "${Param:0:1}" == '-' ]] && isFlagUnset NoMoreOptions ; then
			case "$Param" in
				( "--remotedir="* )
					Sources=( "${Param#--*=}" )
					;;
				( "--force" | "-f" )
					ForceMount=1
					;;
				( * )
					FATAL 1 "Invalid ${MODE} option '${Param}'."
			esac
		else
			isFlagUnset NoMoreOptions && NoMoreOptions=1 && continue
			if [[ "${Param:0:1}" == '-' ]]; then
				Options=( "${Options[@]}" "$Param" )
			else
				FATAL 1 "Unexpected argument ('${Param}')."
			fi

		fi

		break
	done
	return $NDigested
} # parse_options_umount()


function set_environment() {
	# Sets the environment for the specified mode
	local Mode="$1"

	local SetEnvironmentProc="set_environment_${Mode}"

	DBGN 1 "Setting environment for mode '${Mode}'"

	# start from a default environment
	set_default_environment

	declare -f "$SetEnvironmentProc" >& /dev/null
	if [[ $? != 0 ]]; then
		DBGN 2 "No specific environment found."
		return
	fi

	"$SetEnvironmentProc"

} # set_environment()

function set_default_environment() {
	# sets variables for a generic environment

	KerberosNeeded=1
	NoAsRemoteUser=0

	# whether the needed authentication is confirmed to be available
	ConfirmedAuthentication=0

} # set_default_environment()

function set_environment_ping() {
	DBGN 2 "Setting the environment for ping mode."

	# Kerberos is not needed to ping the server:
	KerberosNeeded=0

} # set_environment_ping()


declare MODE=""
declare -i NoMoreOptions=0

declare -i DEBUG=0 QUIET=0 VERBOSE=0 FAKE=0

declare RemoteUser="$USER" RemoteHost='' RemoteDomain=''
declare RemoteHostPrefix='' RemoteHostSuffix=''
declare -a AutoHost
declare -i NoDefaultSSHoptions=0

declare KerberosRealm='' KerberosUser="" KerberosInstance=''
declare KerberosTicketLifetime='1d' KerberosTicketRenewTime='7d'
declare -i KerberosNewTicket=1 KerberosRenewTicket=1 isNAT=0

declare -a Sources Destinations Command
declare -i nSources=0
declare CurrentDestination='' DefaultDestination=''
declare -a ssh_options

declare -i iParam=0 nParams=$#
while [[ $iParam -lt $nParams ]]; do
	let ++iParam
	Param="${!iParam}"

	DBGN 2 "Parsing parameter: '${Param}'"

	if isFlagUnset NoMoreOptions ; then

		# is this the marker of no more options?
		if [[ "$Param" == '--' ]] || [[ "$Param" == '-' ]]; then
			NoMoreOptions=1
			continue
		fi

		# if mode has not been set yet, give it a try
		if [[ -z "$MODE" ]]; then
			case "$Param" in
				( '--help' | '-h' | '-?' | 'help' )    SetOperationMode 'help' ;;
				( '--version' | '-V' | 'version' )     SetOperationMode 'version' ;;
				( '--ssh' | 'ssh' )                    SetOperationMode 'ssh' ;;
				( '--write' | '-w' | 'write' | 'w' )   SetOperationMode 'write' ;;
				( '--read' | '-r' | 'read' | 'r' )     SetOperationMode 'read' ;;
				( '--exec' | '-x' | 'exec' | 'x' )     SetOperationMode 'exec' ;;
				( '--ping' | '-p' | 'ping' | 'p' )     SetOperationMode 'ping' ;;
				( '--tunnel' | '-T' | 'tunnel' | 'T' ) SetOperationMode 'tunnel' ;;
				( '--mount' | '-m' | 'mount' | 'm' )   SetOperationMode 'mount' ;;
				( '--umount' | '-u' | 'umount' | 'u' ) SetOperationMode 'umount' ;;
				( '--unmount' | 'unmount' )            SetOperationMode 'umount' ;;
			esac
			[[ -n "$MODE" ]] && continue
		fi

		# special option (includes a mode set):
		case "$Param" in
			( '--help='* )
				SetOperationMode 'help'
				HelpTopics=( "${HelpTopics[@]}" "${Param#--*=}" )
				continue
				;;
		esac

		# parse the common options
		parse_options_common "$iParam" "$@"
		HandledParameters=$?
		if [[ "$HandledParameters" -ge 1 ]]; then
			# we have handled some parameters, let's skip them
			let iParam+=${HandledParameters}-1
			continue
		fi
	fi

	# mode-specific options (valid only if a mode is specified)
	if [[ -n "$MODE" ]]; then
		parse_options_${MODE} "$iParam" "$@"
		HandledParameters=$?
		if [[ "$HandledParameters" -ge 1 ]]; then
			# we have handled some parameters, let's skip them
			let iParam+=${HandledParameters}-1
			continue
		fi
	fi

done

isFlagSet NoDefaultSSHoptions || ssh_options=( "${ssh_default_options[@]}" "${ssh_options[@]}" )
nSources="${#Sources[@]}"

: ${MODE:='ssh'}

isFlagSet QUIET && VERBOSE=0
: ${KerberosUser:="$RemoteUser"}



################################################################################
### Simple operational modes
###

case "$MODE" in
	( 'help' )
		if [[ "${#HelpTopics[*]}" == 0 ]]; then
			help | less -F
		else
			for HelpTopic in "${HelpTopics[@]}" ; do
				help_${HelpTopic}
				LASTFATAL "Error while printing help on topic '${HelpTopic}'"
			done | less -F
		fi
		exit $?
		;;
	( 'version' )
		RealName="$(basename "$(readlink -f "$0")")"
		if [[ "$RealName" == "${SCRIPTNAME}" ]]; then
			echo "${SCRIPTNAME} version ${SCRIPTVERSION}"
		else
			echo "${SCRIPTNAME} (alias of ${RealName}) version ${SCRIPTVERSION}"
		fi
		exit 0
		;;
esac


################################################################################
### Arrange SSH options
###

if [[ -z "$RemoteHost" ]] && [[ ${#AutoHost[@]} -gt 0 ]] ; then
	RemoteHost="$SCRIPTNAME"
	DBG "Using '${RemoteHost}' as host name (unless in ${AutoHost[@]})."
	for ScriptName in "${AutoHost[@]}" ; do
		[[ "$RemoteHost" == "$ScriptName" ]] || continue
		DBG "Host name '${RemoteHost}' is actually a script name."
		unset RemoteHost
		break
	done
fi

[[ -n "$RemoteHost" ]] || FATAL 1 "Remote host specification is required."


# RemoteHostName is the simple host name (no domain/DNS name)
declare RemoteHostName="${RemoteHost%%.*}"

DBGN 2 "Detected remote host: '${RemoteHost}'"
DBGN 3 "Base host name:       '${RemoteHostName}'"
DBGN 3 "Domain name:          '${RemoteDomain}'"

# RemoteDomainFromHostName is the rest of the host specification (no trailing . though)
declare RemoteDomainFromHostName="${RemoteHost#${RemoteHostName}.}"
[[ "$RemoteDomainFromHostName" == "$RemoteHost" ]] && RemoteDomainFromHostName=''
DBGN 3 "Embedded domain name: '${RemoteDomainFromHostName}'"

# rework the host name
[[ "${RemoteHostName#${RemoteHostPrefix}}" == "$RemoteHostName" ]] && RemoteHostName="${RemoteHostPrefix}${RemoteHostName}"
[[ "${RemoteHostName%${RemoteHostSuffix}}" == "$RemoteHostName" ]] && RemoteHostName+="${RemoteHostSuffix}"

DBGN 2 "Complete host name:   '${RemoteHostName}'"

# RemotePath is the fully qualified host + domain name
declare RemotePath="${RemoteHostName}${RemoteDomainFromHostName:+.${RemoteDomainFromHostName}}"
[[ -n "$RemoteDomain" ]] && [[ -z "$RemoteDomainFromHostName" ]] && RemotePath+=".${RemoteDomain}"

DBGN 3 "Complete host path:   '${RemotePath}'"

declare RemoteHostID="$RemotePath"
if [[ -n "${IPOverride[0]}" ]]; then
	RemoteHostIP=$(OverrideIP "$RemotePath")
	LASTFATAL "aborting."
	if [[ -n "$RemoteHostIP" ]]; then
		RemoteHostID="$RemoteHostIP"
		DBGN 2 "Overridden host IP: ${RemoteHostIP}"
		MSG "Overriding remote host ${RemotePath} as ${RemoteHostID}"
	fi
fi


if [[ -n "$AsRemoteUser" ]]; then
	: ${KerberosInstance:="$AsRemoteUser"}
	: ${KerberosUser:="$RemoteUser"}
elif isFlagSet NoAsRemoteUser ; then
	AsRemoteUser=''
fi

declare RemoteFullPath="${AsRemoteUser:+${AsRemoteUser}@}${RemoteHostID}"
DBGN 2 "Complete user path:   '${RemoteFullPath}'"

set_environment "$MODE"


################################################################################
### Get a Kerberos ticket as needed
###

if isFlagUnset KerberosNeeded ; then
	DBGN 1 "No Kerberos authentication is needed."
	ConfirmedAuthentication=1
elif [[ -n "$KerberosRealm" ]]; then

	ConfirmedAuthentication=0
	declare -i GotKerberosTicket=0

	KerberosUserInstance="${KerberosUser}${KerberosInstance:+/${KerberosInstance}}"
	KerberosFullUser="${KerberosUserInstance}@${KerberosRealm}"

	DBGN 1 "Preparing for Kerberos authentication as: '${KerberosFullUser}'"

	# first try to renew an existing ticket
	if isFlagUnset GotKerberosTicket && isFlagSet KerberosRenewTicket ; then
		DBGN 2 " - attempt to renew any existing ticket"
		Execute --mute $kinit -R "$KerberosFullUser" && GotKerberosTicket=1
	else
		DBGN 2 " (no attempt to renew any existing ticket)"
	fi

	if isFlagUnset GotKerberosTicket && isFlagSet KerberosNewTicket ; then

		DBGN 2 " - attempt to obtain a new ticket"
		declare -a KerberosOptions=(
			${KerberosTicketLifetime:+"-l${KerberosTicketLifetime}"}
			${KerberosTicketRenewTime:+"-r${KerberosTicketRenewTime}"}
		)
		isFlagSet isNAT && KerberosOptions=( "${KerberosOptions[@]}" '-n' )

		echo "Getting a new Kerberos5 ticket: prepare your password."
		Execute $kinit "${KerberosOptions[@]}" "$KerberosFullUser" && GotKerberosTicket=1
	else
		DBGN 2 " (no attempt to obtain a new ticket)"
	fi

	ConfirmedAuthentication="$GotKerberosTicket"
	if isFlagUnset GotKerberosTicket ; then
		ERROR "Couldn't get a new Kerberos5 ticket. Hope there is a valid, existing one."
	fi

else
	DBGN 1 "No Kerberos authentication was requested."
fi


################################################################################
### SSH communication modes
###
declare -i ExitCode=0
case "$MODE" in
	#############################################################################
	( 'ssh' )
		Execute $ssh ${AsRemoteUser:+-l "$AsRemoteUser"} "${ssh_options[@]}" "$RemoteHostID"
		ExitCode=$?
		;;

	#############################################################################
	( 'read' | 'write' )
		# if no destination was ever explicitly specified, assume that the latest
		# parameter is the destination for all the sources;
		# if there is only one source, then assume the destination is the default
		# directory SSH lands to
		if [[ -z "$DefaultDestination" ]]; then
			if [[ $nSources -gt 1 ]]; then
				let --nSources
				DefaultDestination="${Sources[$nSources]}"
				unset Sources[$nSources]
				unset Destinations[$nSources]
			else
				DefaultDestination='.'
			fi
		fi

		[[ $nSources == 0 ]] && FATAL 1 "In ${MODE} mode, at least one source must be specified!"

		declare -i nErrors=0
		declare -i iSource=0
		while [[ $iSource -lt $nSources ]] ; do
			# accumulate sources to be copied into the same destination
			declare -a TheseSources=( )

			declare ThisDestination="${Destinations[iSource]:-${DefaultDestination}}"
			while [[ "${Destinations[iSource]:-${DefaultDestination}}" == "$ThisDestination" ]]; do
				TheseSources=( "${TheseSources[@]}" "${Sources[iSource]}" )

				let ++iSource
				[[ $iSource -ge $nSources ]] && break
			done

			# -r: recursive directory copy; -p: preserve attributes
			if [[ "$MODE" == 'write' ]]; then
				FullDestination="${RemoteFullPath}:${ThisDestination}"
				TransferData "$FullDestination" "${TheseSources[@]}"
			else
				FullDestination="$ThisDestination"
				declare -a FullSources=( )
				for Source in "${TheseSources[@]}" ; do
					FullSources=( "${FullSources[@]}" "${RemoteFullPath}:${Source}" )
				done
				if [[ "${#FullSources[@]}" -gt 1 ]] || [[ "${FullDestination: -1}" == '/' ]]; then
					Execute $mkdir -p "$FullDestination"
				fi
				TransferData "$FullDestination" "${FullSources[@]}"
			fi
			ExitCode=$?
			if [[ $ExitCode != 0 ]]; then
				ERROR "Copy to '${FullDestination}' failed!"
				let ++nErrors
			fi
		done
		exit $nErrors
		;;

	#############################################################################
	( 'exec' )
		Execute $ssh -l "$RemoteUser" "${ssh_options[@]}" "$RemoteHostID" "${Command[@]}"
		ExitCode=$?
		;;

	#############################################################################
	( 'tunnel' )
		TunnelTargetHost='localhost' # default

		# parse target
		[[ "${#TunnelTargetSpecs[@]}" -gt 0 ]] || FATAL 1 "No target of tunnel specified."

		declare -a Tunnels=()
		for TunnelTargetSpec in "${TunnelTargetSpecs[@]}" ; do
			[[ "$TunnelTargetSpec" =~ $TunnelSpecPattern ]] || FATAL 1 "Target specification '${TunnelTargetSpec}' not valid (format: \`localport=>[host:]port\`)."
			TunnelTargetLocalPort="${BASH_REMATCH[1]}"
			TunnelTargetHost="${BASH_REMATCH[4]}"
			TunnelTargetPort="${BASH_REMATCH[5]}"
			Tunnels+=( '-L' "${TunnelTargetLocalPort}:${TunnelTargetHost}:${TunnelTargetPort}" )
		done
		TunnelOptions=( "${Tunnels[@]}" -o 'ExitOnForwardFailure yes' -o 'TCPKeepAlive yes' -o 'ServerAliveInterval 15' )
		[[ "${#Command[@]}" == 0 ]] && TunnelOptions+=( '-N' ) && GoToBackground=1
		isFlagSet GoToBackground && TunnelOptions+=( '-f' )
		isIP6 "$TunnelTargetHost" || TunnelOptions+=( '-4' )
		Execute $ssh -l "$RemoteUser" "${ssh_options[@]}" "${TunnelOptions[@]}" "$RemoteHostID" "${Command[@]}"
		ExitCode=$?
		;;

	#############################################################################
	( 'ping' )
		Execute $ping "${Options[@]}" -- "$RemoteHostID"
		ExitCode=$?
		;;

	#############################################################################
	( 'mount' )
		SetMountPoint "${Destinations[0]}"

		if isFlagUnset ConfirmedAuthentication && isOSX ; then

			# on OSX sshfs is fragile and attempting to use it with no valid
			# authentication makes the OS unstable.
			FATAL 1 "Remote mounting NOT attempted: make sure authentication succeeds and then try again."

		fi

		Execute $mkdir -p "$MountPoint"
		LASTFATAL 1 "Can't write the mount point '${MountPoint}'"

		if isFlagSet DoRemount ; then
			# this is quite crude...
			Unmount "$MountPoint" # "$ForceMount"
			res=$?
			[[ $res != 0 ]] && DBGN 2 "umount failed with exit code ${res}. Ignoring."
		fi

		RemoteDir="${RemoteHostID}:${Sources[0]}"

		Execute $sshfs "$RemoteDir" "$MountPoint" -o follow_symlinks "${Options[@]}"
		ExitCode=$?
		if [[ $ExitCode == 0 ]]; then
			MSG "'${RemoteDir}' mounted at '${MountPoint}'. Unmount with \`fusermount -u '${MountPoint}'\`."
		else
			# attempt to clean up the residual of the mount, but leave the mount directory there
			Unmount "$MountPoint"
			res=$?
			[[ $res != 0 ]] && DBGN 2 "Cleanup umount failed with exit code ${res}. Too bad."
		fi
		;;

	#############################################################################
	( 'umount' )
		SetMountPoint "${Destinations[0]}"
		Unmount "$MountPoint"
		;;

	#############################################################################
	( * ) FATAL 1 "Unknown SSH operation '${MODE}'." ;;
esac


exit $ExitCode
